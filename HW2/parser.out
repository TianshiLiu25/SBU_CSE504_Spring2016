Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    COMMENT
    CPPCOMMENT

Grammar

Rule 0     S' -> pp
Rule 1     pp -> program
Rule 2     program -> MYST
Rule 3     program -> program class_decl
Rule 4     program -> program MYED
Rule 5     program -> program error
Rule 6     class_decl1 -> CLASS ID LBIG
Rule 7     class_decl1 -> CLASS ID EXTENDS ID LBIG
Rule 8     class_decl1 -> error ID EXTENDS ID LBIG
Rule 9     class_decl1 -> error ID LBIG
Rule 10    class_decl1 -> CLASS error EXTENDS ID LBIG
Rule 11    class_decl1 -> CLASS error LBIG
Rule 12    class_decl1 -> CLASS ID error
Rule 13    class_decl1 -> CLASS ID EXTENDS ID error
Rule 14    class_decl2 -> class_decl1 class_body_decl
Rule 15    class_decl2 -> class_decl2 class_body_decl
Rule 16    class_decl -> class_decl2 RBIG
Rule 17    class_body_decl -> field_decl
Rule 18    class_body_decl -> method_decl
Rule 19    class_body_decl -> constructor_decl
Rule 20    field_decl -> modifier var_decl
Rule 21    modifier_first -> PUBLIC
Rule 22    modifier_first -> PRIVATE
Rule 23    modifier_first -> <empty>
Rule 24    modifier -> modifier_first
Rule 25    modifier -> modifier_first STATIC
Rule 26    var_decl -> type variables SEMICOLON
Rule 27    var_decl -> type variables error
Rule 28    type -> INT
Rule 29    type -> FLOAT
Rule 30    type -> BOOLEAN
Rule 31    type -> ID
Rule 32    type -> error
Rule 33    variables -> variable
Rule 34    variables -> variables COMMA variable
Rule 35    variable -> ID
Rule 36    variable -> variable LSQ RSQ
Rule 37    variable -> variable LSQ error
Rule 38    method_decl1 -> modifier type ID LPAREN
Rule 39    method_decl1 -> modifier VOID ID LPAREN
Rule 40    method_decl -> method_decl1 formals RPAREN block
Rule 41    method_decl -> method_decl1 RPAREN block
Rule 42    constructor_decl -> modifier ID LPAREN RPAREN block
Rule 43    constructor_decl -> modifier ID LPAREN formals RPAREN block
Rule 44    constructor_decl -> modifier ID error RPAREN block
Rule 45    constructor_decl -> modifier ID error formals RPAREN block
Rule 46    formals -> formal_param
Rule 47    formals -> formals COMMA formal_param
Rule 48    formal_param -> type variable
Rule 49    block1 -> LBIG
Rule 50    block1 -> block1 stmt
Rule 51    block -> block1 RBIG
Rule 52    stmt -> noncompleteif_stmt
Rule 53    stmt -> other_stmt
Rule 54    noncompleteif_stmt -> IF LPAREN expr RPAREN stmt
Rule 55    noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
Rule 56    noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt
Rule 57    noncompleteif_stmt -> forbasic noncompleteif_stmt
Rule 58    other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt
Rule 59    other_stmt -> WHILE LPAREN expr RPAREN other_stmt
Rule 60    forbasic1 -> FOR LPAREN SEMICOLON
Rule 61    forbasic1 -> FOR LPAREN stmt_expr SEMICOLON
Rule 62    forbasic2 -> forbasic1 SEMICOLON
Rule 63    forbasic2 -> forbasic1 expr SEMICOLON
Rule 64    forbasic -> forbasic2 RPAREN
Rule 65    forbasic -> forbasic2 stmt_expr RPAREN
Rule 66    other_stmt -> forbasic other_stmt
Rule 67    other_stmt -> RETURN SEMICOLON
Rule 68    other_stmt -> RETURN expr SEMICOLON
Rule 69    other_stmt -> RETURN error
Rule 70    other_stmt -> RETURN expr error
Rule 71    other_stmt -> stmt_expr SEMICOLON
Rule 72    other_stmt -> stmt_expr error
Rule 73    other_stmt -> BREAK SEMICOLON
Rule 74    other_stmt -> BREAK error
Rule 75    other_stmt -> CONTINUE SEMICOLON
Rule 76    other_stmt -> CONTINUE error
Rule 77    other_stmt -> block
Rule 78    other_stmt -> var_decl
Rule 79    other_stmt -> SEMICOLON
Rule 80    literal -> INT_CONST
Rule 81    literal -> FLOAT_CONST
Rule 82    literal -> STRING_CONST
Rule 83    literal -> NULL
Rule 84    literal -> TRUE
Rule 85    literal -> FALSE
Rule 86    primary -> literal
Rule 87    primary -> THIS
Rule 88    primary -> SUPER
Rule 89    primary -> LPAREN expr RPAREN
Rule 90    pnew1 -> NEW ID
Rule 91    pnew -> pnew1 LPAREN RPAREN
Rule 92    pnew -> pnew1 LPAREN arguments RPAREN
Rule 93    primary -> pnew
Rule 94    primary -> lhs
Rule 95    primary -> method_invocation
Rule 96    arguments -> expr
Rule 97    arguments -> arguments COMMA expr
Rule 98    lhs -> field_access
Rule 99    lhs -> array_access
Rule 100   field_access -> primary POINT ID
Rule 101   field_access -> ID
Rule 102   array_access -> primary LSQ expr RSQ
Rule 103   method_invocation -> field_access LPAREN RPAREN
Rule 104   method_invocation -> field_access LPAREN arguments RPAREN
Rule 105   expr -> expr PLUS expr
Rule 106   expr -> expr MINUS expr
Rule 107   expr -> expr MULTI expr
Rule 108   expr -> expr DIVIDE expr
Rule 109   expr -> expr AND expr
Rule 110   expr -> expr OR expr
Rule 111   expr -> expr EQUAL expr
Rule 112   expr -> expr NOTEQUAL expr
Rule 113   expr -> expr LESS expr
Rule 114   expr -> expr GREATER expr
Rule 115   expr -> expr LESSEQUAL expr
Rule 116   expr -> expr GREATEREQUAL expr
Rule 117   expr -> primary
Rule 118   expr -> assign
Rule 119   expr -> newarray
Rule 120   expr -> MINUS expr
Rule 121   expr -> PLUS expr
Rule 122   expr -> NOT expr
Rule 123   newarray -> newarrayp
Rule 124   newarray -> newarrayw
Rule 125   newarrayw -> newarrayw LSQ RSQ
Rule 126   newarrayw -> newarrayp LSQ RSQ
Rule 127   newarrayp -> NEW type LSQ expr RSQ
Rule 128   newarrayp -> newarrayp LSQ expr RSQ
Rule 129   assign -> lhs ASSIGN expr
Rule 130   assign -> lhs INCREMENT
Rule 131   assign -> INCREMENT lhs
Rule 132   assign -> lhs DECREMENT
Rule 133   assign -> DECREMENT lhs
Rule 134   stmt_expr -> assign
Rule 135   stmt_expr -> method_invocation
Rule 136   stmt_expr -> error

Terminals, with rules where they appear

AND                  : 109
ASSIGN               : 129
BOOLEAN              : 30
BREAK                : 73 74
CLASS                : 6 7 10 11 12 13
COMMA                : 34 47 97
COMMENT              : 
CONTINUE             : 75 76
CPPCOMMENT           : 
DECREMENT            : 132 133
DIVIDE               : 108
DO                   : 
ELSE                 : 55 58
EQUAL                : 111
EXTENDS              : 7 8 10 13
FALSE                : 85
FLOAT                : 29
FLOAT_CONST          : 81
FOR                  : 60 61
GREATER              : 114
GREATEREQUAL         : 116
ID                   : 6 7 7 8 8 9 10 12 13 13 31 35 38 39 42 43 44 45 90 100 101
IF                   : 54 55 58
INCREMENT            : 130 131
INT                  : 28
INT_CONST            : 80
LBIG                 : 6 7 8 9 10 11 49
LESS                 : 113
LESSEQUAL            : 115
LPAREN               : 38 39 42 43 54 55 56 58 59 60 61 89 91 92 103 104
LSQ                  : 36 37 102 125 126 127 128
MINUS                : 106 120
MULTI                : 107
MYED                 : 4
MYST                 : 2
NEW                  : 90 127
NOT                  : 122
NOTEQUAL             : 112
NULL                 : 83
OR                   : 110
PLUS                 : 105 121
POINT                : 100
PRIVATE              : 22
PUBLIC               : 21
RBIG                 : 16 51
RETURN               : 67 68 69 70
RPAREN               : 40 41 42 43 44 45 54 55 56 58 59 64 65 89 91 92 103 104
RSQ                  : 36 102 125 126 127 128
SEMICOLON            : 26 60 61 62 63 67 68 71 73 75 79
STATIC               : 25
STRING_CONST         : 82
SUPER                : 88
THIS                 : 87
TRUE                 : 84
VOID                 : 39
WHILE                : 56 59
error                : 5 8 9 10 11 12 13 27 32 37 44 45 69 70 72 74 76 136

Nonterminals, with rules where they appear

arguments            : 92 97 104
array_access         : 99
assign               : 118 134
block                : 40 41 42 43 44 45 77
block1               : 50 51
class_body_decl      : 14 15
class_decl           : 3
class_decl1          : 14
class_decl2          : 15 16
constructor_decl     : 19
expr                 : 54 55 56 58 59 63 68 70 89 96 97 102 105 105 106 106 107 107 108 108 109 109 110 110 111 111 112 112 113 113 114 114 115 115 116 116 120 121 122 127 128 129
field_access         : 98 103 104
field_decl           : 17
forbasic             : 57 66
forbasic1            : 62 63
forbasic2            : 64 65
formal_param         : 46 47
formals              : 40 43 45 47
lhs                  : 94 129 130 131 132 133
literal              : 86
method_decl          : 18
method_decl1         : 40 41
method_invocation    : 95 135
modifier             : 20 38 39 42 43 44 45
modifier_first       : 24 25
newarray             : 119
newarrayp            : 123 126 128
newarrayw            : 124 125
noncompleteif_stmt   : 52 55 56 57
other_stmt           : 53 55 58 58 59 66
pnew                 : 93
pnew1                : 91 92
pp                   : 0
primary              : 100 102 117
program              : 1 3 4 5
stmt                 : 50 54
stmt_expr            : 61 65 71 72
type                 : 26 27 38 48 127
var_decl             : 20 78
variable             : 33 34 36 37 48
variables            : 26 27 34

Parsing method: LALR

state 0

    (0) S' -> . pp
    (1) pp -> . program
    (2) program -> . MYST
    (3) program -> . program class_decl
    (4) program -> . program MYED
    (5) program -> . program error

    MYST            shift and go to state 2

    pp                             shift and go to state 1
    program                        shift and go to state 3

state 1

    (0) S' -> pp .



state 2

    (2) program -> MYST .

    MYED            reduce using rule 2 (program -> MYST .)
    error           reduce using rule 2 (program -> MYST .)
    CLASS           reduce using rule 2 (program -> MYST .)
    $end            reduce using rule 2 (program -> MYST .)


state 3

    (1) pp -> program .
    (3) program -> program . class_decl
    (4) program -> program . MYED
    (5) program -> program . error
    (16) class_decl -> . class_decl2 RBIG
    (14) class_decl2 -> . class_decl1 class_body_decl
    (15) class_decl2 -> . class_decl2 class_body_decl
    (6) class_decl1 -> . CLASS ID LBIG
    (7) class_decl1 -> . CLASS ID EXTENDS ID LBIG
    (8) class_decl1 -> . error ID EXTENDS ID LBIG
    (9) class_decl1 -> . error ID LBIG
    (10) class_decl1 -> . CLASS error EXTENDS ID LBIG
    (11) class_decl1 -> . CLASS error LBIG
    (12) class_decl1 -> . CLASS ID error
    (13) class_decl1 -> . CLASS ID EXTENDS ID error

    $end            reduce using rule 1 (pp -> program .)
    MYED            shift and go to state 9
    error           shift and go to state 8
    CLASS           shift and go to state 6

    class_decl2                    shift and go to state 4
    class_decl                     shift and go to state 7
    class_decl1                    shift and go to state 5

state 4

    (16) class_decl -> class_decl2 . RBIG
    (15) class_decl2 -> class_decl2 . class_body_decl
    (17) class_body_decl -> . field_decl
    (18) class_body_decl -> . method_decl
    (19) class_body_decl -> . constructor_decl
    (20) field_decl -> . modifier var_decl
    (40) method_decl -> . method_decl1 formals RPAREN block
    (41) method_decl -> . method_decl1 RPAREN block
    (42) constructor_decl -> . modifier ID LPAREN RPAREN block
    (43) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (44) constructor_decl -> . modifier ID error RPAREN block
    (45) constructor_decl -> . modifier ID error formals RPAREN block
    (24) modifier -> . modifier_first
    (25) modifier -> . modifier_first STATIC
    (38) method_decl1 -> . modifier type ID LPAREN
    (39) method_decl1 -> . modifier VOID ID LPAREN
    (21) modifier_first -> . PUBLIC
    (22) modifier_first -> . PRIVATE
    (23) modifier_first -> .

    RBIG            shift and go to state 19
    PUBLIC          shift and go to state 17
    PRIVATE         shift and go to state 16
    STATIC          reduce using rule 23 (modifier_first -> .)
    ID              reduce using rule 23 (modifier_first -> .)
    VOID            reduce using rule 23 (modifier_first -> .)
    INT             reduce using rule 23 (modifier_first -> .)
    FLOAT           reduce using rule 23 (modifier_first -> .)
    BOOLEAN         reduce using rule 23 (modifier_first -> .)
    error           reduce using rule 23 (modifier_first -> .)

    class_body_decl                shift and go to state 10
    modifier_first                 shift and go to state 11
    field_decl                     shift and go to state 12
    constructor_decl               shift and go to state 13
    method_decl                    shift and go to state 14
    method_decl1                   shift and go to state 15
    modifier                       shift and go to state 18

state 5

    (14) class_decl2 -> class_decl1 . class_body_decl
    (17) class_body_decl -> . field_decl
    (18) class_body_decl -> . method_decl
    (19) class_body_decl -> . constructor_decl
    (20) field_decl -> . modifier var_decl
    (40) method_decl -> . method_decl1 formals RPAREN block
    (41) method_decl -> . method_decl1 RPAREN block
    (42) constructor_decl -> . modifier ID LPAREN RPAREN block
    (43) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (44) constructor_decl -> . modifier ID error RPAREN block
    (45) constructor_decl -> . modifier ID error formals RPAREN block
    (24) modifier -> . modifier_first
    (25) modifier -> . modifier_first STATIC
    (38) method_decl1 -> . modifier type ID LPAREN
    (39) method_decl1 -> . modifier VOID ID LPAREN
    (21) modifier_first -> . PUBLIC
    (22) modifier_first -> . PRIVATE
    (23) modifier_first -> .

    PUBLIC          shift and go to state 17
    PRIVATE         shift and go to state 16
    STATIC          reduce using rule 23 (modifier_first -> .)
    ID              reduce using rule 23 (modifier_first -> .)
    VOID            reduce using rule 23 (modifier_first -> .)
    INT             reduce using rule 23 (modifier_first -> .)
    FLOAT           reduce using rule 23 (modifier_first -> .)
    BOOLEAN         reduce using rule 23 (modifier_first -> .)
    error           reduce using rule 23 (modifier_first -> .)

    class_body_decl                shift and go to state 20
    modifier_first                 shift and go to state 11
    field_decl                     shift and go to state 12
    constructor_decl               shift and go to state 13
    method_decl                    shift and go to state 14
    method_decl1                   shift and go to state 15
    modifier                       shift and go to state 18

state 6

    (6) class_decl1 -> CLASS . ID LBIG
    (7) class_decl1 -> CLASS . ID EXTENDS ID LBIG
    (10) class_decl1 -> CLASS . error EXTENDS ID LBIG
    (11) class_decl1 -> CLASS . error LBIG
    (12) class_decl1 -> CLASS . ID error
    (13) class_decl1 -> CLASS . ID EXTENDS ID error

    ID              shift and go to state 22
    error           shift and go to state 21


state 7

    (3) program -> program class_decl .

    MYED            reduce using rule 3 (program -> program class_decl .)
    error           reduce using rule 3 (program -> program class_decl .)
    CLASS           reduce using rule 3 (program -> program class_decl .)
    $end            reduce using rule 3 (program -> program class_decl .)


state 8

    (5) program -> program error .
    (8) class_decl1 -> error . ID EXTENDS ID LBIG
    (9) class_decl1 -> error . ID LBIG

    MYED            reduce using rule 5 (program -> program error .)
    error           reduce using rule 5 (program -> program error .)
    CLASS           reduce using rule 5 (program -> program error .)
    $end            reduce using rule 5 (program -> program error .)
    ID              shift and go to state 23


state 9

    (4) program -> program MYED .

    MYED            reduce using rule 4 (program -> program MYED .)
    error           reduce using rule 4 (program -> program MYED .)
    CLASS           reduce using rule 4 (program -> program MYED .)
    $end            reduce using rule 4 (program -> program MYED .)


state 10

    (15) class_decl2 -> class_decl2 class_body_decl .

    RBIG            reduce using rule 15 (class_decl2 -> class_decl2 class_body_decl .)
    PUBLIC          reduce using rule 15 (class_decl2 -> class_decl2 class_body_decl .)
    PRIVATE         reduce using rule 15 (class_decl2 -> class_decl2 class_body_decl .)
    ID              reduce using rule 15 (class_decl2 -> class_decl2 class_body_decl .)
    VOID            reduce using rule 15 (class_decl2 -> class_decl2 class_body_decl .)
    INT             reduce using rule 15 (class_decl2 -> class_decl2 class_body_decl .)
    FLOAT           reduce using rule 15 (class_decl2 -> class_decl2 class_body_decl .)
    BOOLEAN         reduce using rule 15 (class_decl2 -> class_decl2 class_body_decl .)
    error           reduce using rule 15 (class_decl2 -> class_decl2 class_body_decl .)
    STATIC          reduce using rule 15 (class_decl2 -> class_decl2 class_body_decl .)


state 11

    (24) modifier -> modifier_first .
    (25) modifier -> modifier_first . STATIC

    ID              reduce using rule 24 (modifier -> modifier_first .)
    VOID            reduce using rule 24 (modifier -> modifier_first .)
    INT             reduce using rule 24 (modifier -> modifier_first .)
    FLOAT           reduce using rule 24 (modifier -> modifier_first .)
    BOOLEAN         reduce using rule 24 (modifier -> modifier_first .)
    error           reduce using rule 24 (modifier -> modifier_first .)
    STATIC          shift and go to state 24


state 12

    (17) class_body_decl -> field_decl .

    RBIG            reduce using rule 17 (class_body_decl -> field_decl .)
    PUBLIC          reduce using rule 17 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 17 (class_body_decl -> field_decl .)
    ID              reduce using rule 17 (class_body_decl -> field_decl .)
    VOID            reduce using rule 17 (class_body_decl -> field_decl .)
    INT             reduce using rule 17 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 17 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 17 (class_body_decl -> field_decl .)
    error           reduce using rule 17 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 17 (class_body_decl -> field_decl .)


state 13

    (19) class_body_decl -> constructor_decl .

    RBIG            reduce using rule 19 (class_body_decl -> constructor_decl .)
    PUBLIC          reduce using rule 19 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 19 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 19 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 19 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 19 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 19 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 19 (class_body_decl -> constructor_decl .)
    error           reduce using rule 19 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 19 (class_body_decl -> constructor_decl .)


state 14

    (18) class_body_decl -> method_decl .

    RBIG            reduce using rule 18 (class_body_decl -> method_decl .)
    PUBLIC          reduce using rule 18 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 18 (class_body_decl -> method_decl .)
    ID              reduce using rule 18 (class_body_decl -> method_decl .)
    VOID            reduce using rule 18 (class_body_decl -> method_decl .)
    INT             reduce using rule 18 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 18 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 18 (class_body_decl -> method_decl .)
    error           reduce using rule 18 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 18 (class_body_decl -> method_decl .)


state 15

    (40) method_decl -> method_decl1 . formals RPAREN block
    (41) method_decl -> method_decl1 . RPAREN block
    (46) formals -> . formal_param
    (47) formals -> . formals COMMA formal_param
    (48) formal_param -> . type variable
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error

    RPAREN          shift and go to state 26
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 32
    error           shift and go to state 30

    formal_param                   shift and go to state 25
    type                           shift and go to state 31
    formals                        shift and go to state 33

state 16

    (22) modifier_first -> PRIVATE .

    STATIC          reduce using rule 22 (modifier_first -> PRIVATE .)
    ID              reduce using rule 22 (modifier_first -> PRIVATE .)
    VOID            reduce using rule 22 (modifier_first -> PRIVATE .)
    INT             reduce using rule 22 (modifier_first -> PRIVATE .)
    FLOAT           reduce using rule 22 (modifier_first -> PRIVATE .)
    BOOLEAN         reduce using rule 22 (modifier_first -> PRIVATE .)
    error           reduce using rule 22 (modifier_first -> PRIVATE .)


state 17

    (21) modifier_first -> PUBLIC .

    STATIC          reduce using rule 21 (modifier_first -> PUBLIC .)
    ID              reduce using rule 21 (modifier_first -> PUBLIC .)
    VOID            reduce using rule 21 (modifier_first -> PUBLIC .)
    INT             reduce using rule 21 (modifier_first -> PUBLIC .)
    FLOAT           reduce using rule 21 (modifier_first -> PUBLIC .)
    BOOLEAN         reduce using rule 21 (modifier_first -> PUBLIC .)
    error           reduce using rule 21 (modifier_first -> PUBLIC .)


state 18

    (20) field_decl -> modifier . var_decl
    (42) constructor_decl -> modifier . ID LPAREN RPAREN block
    (43) constructor_decl -> modifier . ID LPAREN formals RPAREN block
    (44) constructor_decl -> modifier . ID error RPAREN block
    (45) constructor_decl -> modifier . ID error formals RPAREN block
    (38) method_decl1 -> modifier . type ID LPAREN
    (39) method_decl1 -> modifier . VOID ID LPAREN
    (26) var_decl -> . type variables SEMICOLON
    (27) var_decl -> . type variables error
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error

    ID              shift and go to state 37
    VOID            shift and go to state 34
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    error           shift and go to state 30

    var_decl                       shift and go to state 35
    type                           shift and go to state 36

state 19

    (16) class_decl -> class_decl2 RBIG .

    MYED            reduce using rule 16 (class_decl -> class_decl2 RBIG .)
    error           reduce using rule 16 (class_decl -> class_decl2 RBIG .)
    CLASS           reduce using rule 16 (class_decl -> class_decl2 RBIG .)
    $end            reduce using rule 16 (class_decl -> class_decl2 RBIG .)


state 20

    (14) class_decl2 -> class_decl1 class_body_decl .

    RBIG            reduce using rule 14 (class_decl2 -> class_decl1 class_body_decl .)
    PUBLIC          reduce using rule 14 (class_decl2 -> class_decl1 class_body_decl .)
    PRIVATE         reduce using rule 14 (class_decl2 -> class_decl1 class_body_decl .)
    ID              reduce using rule 14 (class_decl2 -> class_decl1 class_body_decl .)
    VOID            reduce using rule 14 (class_decl2 -> class_decl1 class_body_decl .)
    INT             reduce using rule 14 (class_decl2 -> class_decl1 class_body_decl .)
    FLOAT           reduce using rule 14 (class_decl2 -> class_decl1 class_body_decl .)
    BOOLEAN         reduce using rule 14 (class_decl2 -> class_decl1 class_body_decl .)
    error           reduce using rule 14 (class_decl2 -> class_decl1 class_body_decl .)
    STATIC          reduce using rule 14 (class_decl2 -> class_decl1 class_body_decl .)


state 21

    (10) class_decl1 -> CLASS error . EXTENDS ID LBIG
    (11) class_decl1 -> CLASS error . LBIG

    EXTENDS         shift and go to state 39
    LBIG            shift and go to state 38


state 22

    (6) class_decl1 -> CLASS ID . LBIG
    (7) class_decl1 -> CLASS ID . EXTENDS ID LBIG
    (12) class_decl1 -> CLASS ID . error
    (13) class_decl1 -> CLASS ID . EXTENDS ID error

    LBIG            shift and go to state 40
    EXTENDS         shift and go to state 42
    error           shift and go to state 41


state 23

    (8) class_decl1 -> error ID . EXTENDS ID LBIG
    (9) class_decl1 -> error ID . LBIG

    EXTENDS         shift and go to state 44
    LBIG            shift and go to state 43


state 24

    (25) modifier -> modifier_first STATIC .

    ID              reduce using rule 25 (modifier -> modifier_first STATIC .)
    VOID            reduce using rule 25 (modifier -> modifier_first STATIC .)
    INT             reduce using rule 25 (modifier -> modifier_first STATIC .)
    FLOAT           reduce using rule 25 (modifier -> modifier_first STATIC .)
    BOOLEAN         reduce using rule 25 (modifier -> modifier_first STATIC .)
    error           reduce using rule 25 (modifier -> modifier_first STATIC .)


state 25

    (46) formals -> formal_param .

    RPAREN          reduce using rule 46 (formals -> formal_param .)
    COMMA           reduce using rule 46 (formals -> formal_param .)


state 26

    (41) method_decl -> method_decl1 RPAREN . block
    (51) block -> . block1 RBIG
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt

    LBIG            shift and go to state 46

    block1                         shift and go to state 45
    block                          shift and go to state 47

state 27

    (28) type -> INT .

    ID              reduce using rule 28 (type -> INT .)
    LSQ             reduce using rule 28 (type -> INT .)


state 28

    (29) type -> FLOAT .

    ID              reduce using rule 29 (type -> FLOAT .)
    LSQ             reduce using rule 29 (type -> FLOAT .)


state 29

    (30) type -> BOOLEAN .

    ID              reduce using rule 30 (type -> BOOLEAN .)
    LSQ             reduce using rule 30 (type -> BOOLEAN .)


state 30

    (32) type -> error .

    LSQ             reduce using rule 32 (type -> error .)
    ID              reduce using rule 32 (type -> error .)


state 31

    (48) formal_param -> type . variable
    (35) variable -> . ID
    (36) variable -> . variable LSQ RSQ
    (37) variable -> . variable LSQ error

    ID              shift and go to state 48

    variable                       shift and go to state 49

state 32

    (31) type -> ID .

    ID              reduce using rule 31 (type -> ID .)


state 33

    (40) method_decl -> method_decl1 formals . RPAREN block
    (47) formals -> formals . COMMA formal_param

    RPAREN          shift and go to state 50
    COMMA           shift and go to state 51


state 34

    (39) method_decl1 -> modifier VOID . ID LPAREN

    ID              shift and go to state 52


state 35

    (20) field_decl -> modifier var_decl .

    RBIG            reduce using rule 20 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 20 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 20 (field_decl -> modifier var_decl .)
    ID              reduce using rule 20 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 20 (field_decl -> modifier var_decl .)
    INT             reduce using rule 20 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 20 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 20 (field_decl -> modifier var_decl .)
    error           reduce using rule 20 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 20 (field_decl -> modifier var_decl .)


state 36

    (38) method_decl1 -> modifier type . ID LPAREN
    (26) var_decl -> type . variables SEMICOLON
    (27) var_decl -> type . variables error
    (33) variables -> . variable
    (34) variables -> . variables COMMA variable
    (35) variable -> . ID
    (36) variable -> . variable LSQ RSQ
    (37) variable -> . variable LSQ error

    ID              shift and go to state 55

    variable                       shift and go to state 54
    variables                      shift and go to state 53

state 37

    (42) constructor_decl -> modifier ID . LPAREN RPAREN block
    (43) constructor_decl -> modifier ID . LPAREN formals RPAREN block
    (44) constructor_decl -> modifier ID . error RPAREN block
    (45) constructor_decl -> modifier ID . error formals RPAREN block
    (31) type -> ID .

    LPAREN          shift and go to state 56
    error           shift and go to state 57
    ID              reduce using rule 31 (type -> ID .)


state 38

    (11) class_decl1 -> CLASS error LBIG .

    PUBLIC          reduce using rule 11 (class_decl1 -> CLASS error LBIG .)
    PRIVATE         reduce using rule 11 (class_decl1 -> CLASS error LBIG .)
    ID              reduce using rule 11 (class_decl1 -> CLASS error LBIG .)
    VOID            reduce using rule 11 (class_decl1 -> CLASS error LBIG .)
    INT             reduce using rule 11 (class_decl1 -> CLASS error LBIG .)
    FLOAT           reduce using rule 11 (class_decl1 -> CLASS error LBIG .)
    BOOLEAN         reduce using rule 11 (class_decl1 -> CLASS error LBIG .)
    error           reduce using rule 11 (class_decl1 -> CLASS error LBIG .)
    STATIC          reduce using rule 11 (class_decl1 -> CLASS error LBIG .)


state 39

    (10) class_decl1 -> CLASS error EXTENDS . ID LBIG

    ID              shift and go to state 58


state 40

    (6) class_decl1 -> CLASS ID LBIG .

    PUBLIC          reduce using rule 6 (class_decl1 -> CLASS ID LBIG .)
    PRIVATE         reduce using rule 6 (class_decl1 -> CLASS ID LBIG .)
    ID              reduce using rule 6 (class_decl1 -> CLASS ID LBIG .)
    VOID            reduce using rule 6 (class_decl1 -> CLASS ID LBIG .)
    INT             reduce using rule 6 (class_decl1 -> CLASS ID LBIG .)
    FLOAT           reduce using rule 6 (class_decl1 -> CLASS ID LBIG .)
    BOOLEAN         reduce using rule 6 (class_decl1 -> CLASS ID LBIG .)
    error           reduce using rule 6 (class_decl1 -> CLASS ID LBIG .)
    STATIC          reduce using rule 6 (class_decl1 -> CLASS ID LBIG .)


state 41

    (12) class_decl1 -> CLASS ID error .

    PUBLIC          reduce using rule 12 (class_decl1 -> CLASS ID error .)
    PRIVATE         reduce using rule 12 (class_decl1 -> CLASS ID error .)
    ID              reduce using rule 12 (class_decl1 -> CLASS ID error .)
    VOID            reduce using rule 12 (class_decl1 -> CLASS ID error .)
    INT             reduce using rule 12 (class_decl1 -> CLASS ID error .)
    FLOAT           reduce using rule 12 (class_decl1 -> CLASS ID error .)
    BOOLEAN         reduce using rule 12 (class_decl1 -> CLASS ID error .)
    error           reduce using rule 12 (class_decl1 -> CLASS ID error .)
    STATIC          reduce using rule 12 (class_decl1 -> CLASS ID error .)


state 42

    (7) class_decl1 -> CLASS ID EXTENDS . ID LBIG
    (13) class_decl1 -> CLASS ID EXTENDS . ID error

    ID              shift and go to state 59


state 43

    (9) class_decl1 -> error ID LBIG .

    PUBLIC          reduce using rule 9 (class_decl1 -> error ID LBIG .)
    PRIVATE         reduce using rule 9 (class_decl1 -> error ID LBIG .)
    ID              reduce using rule 9 (class_decl1 -> error ID LBIG .)
    VOID            reduce using rule 9 (class_decl1 -> error ID LBIG .)
    INT             reduce using rule 9 (class_decl1 -> error ID LBIG .)
    FLOAT           reduce using rule 9 (class_decl1 -> error ID LBIG .)
    BOOLEAN         reduce using rule 9 (class_decl1 -> error ID LBIG .)
    error           reduce using rule 9 (class_decl1 -> error ID LBIG .)
    STATIC          reduce using rule 9 (class_decl1 -> error ID LBIG .)


state 44

    (8) class_decl1 -> error ID EXTENDS . ID LBIG

    ID              shift and go to state 60


state 45

    (51) block -> block1 . RBIG
    (50) block1 -> block1 . stmt
    (52) stmt -> . noncompleteif_stmt
    (53) stmt -> . other_stmt
    (54) noncompleteif_stmt -> . IF LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
    (56) noncompleteif_stmt -> . WHILE LPAREN expr RPAREN noncompleteif_stmt
    (57) noncompleteif_stmt -> . forbasic noncompleteif_stmt
    (58) other_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE other_stmt
    (59) other_stmt -> . WHILE LPAREN expr RPAREN other_stmt
    (66) other_stmt -> . forbasic other_stmt
    (67) other_stmt -> . RETURN SEMICOLON
    (68) other_stmt -> . RETURN expr SEMICOLON
    (69) other_stmt -> . RETURN error
    (70) other_stmt -> . RETURN expr error
    (71) other_stmt -> . stmt_expr SEMICOLON
    (72) other_stmt -> . stmt_expr error
    (73) other_stmt -> . BREAK SEMICOLON
    (74) other_stmt -> . BREAK error
    (75) other_stmt -> . CONTINUE SEMICOLON
    (76) other_stmt -> . CONTINUE error
    (77) other_stmt -> . block
    (78) other_stmt -> . var_decl
    (79) other_stmt -> . SEMICOLON
    (64) forbasic -> . forbasic2 RPAREN
    (65) forbasic -> . forbasic2 stmt_expr RPAREN
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (51) block -> . block1 RBIG
    (26) var_decl -> . type variables SEMICOLON
    (27) var_decl -> . type variables error
    (62) forbasic2 -> . forbasic1 SEMICOLON
    (63) forbasic2 -> . forbasic1 expr SEMICOLON
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error
    (60) forbasic1 -> . FOR LPAREN SEMICOLON
    (61) forbasic1 -> . FOR LPAREN stmt_expr SEMICOLON
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    RBIG            shift and go to state 99
    IF              shift and go to state 89
    WHILE           shift and go to state 63
    RETURN          shift and go to state 61
    BREAK           shift and go to state 93
    CONTINUE        shift and go to state 95
    SEMICOLON       shift and go to state 70
    error           shift and go to state 97
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    LBIG            shift and go to state 46
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 88
    FOR             shift and go to state 80
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    block1                         shift and go to state 45
    primary                        shift and go to state 62
    array_access                   shift and go to state 67
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 74
    literal                        shift and go to state 72
    forbasic                       shift and go to state 75
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    forbasic2                      shift and go to state 82
    stmt                           shift and go to state 84
    forbasic1                      shift and go to state 87
    noncompleteif_stmt             shift and go to state 90
    var_decl                       shift and go to state 92
    other_stmt                     shift and go to state 94
    lhs                            shift and go to state 96
    assign                         shift and go to state 100
    block                          shift and go to state 101

state 46

    (49) block1 -> LBIG .

    RBIG            reduce using rule 49 (block1 -> LBIG .)
    IF              reduce using rule 49 (block1 -> LBIG .)
    WHILE           reduce using rule 49 (block1 -> LBIG .)
    RETURN          reduce using rule 49 (block1 -> LBIG .)
    BREAK           reduce using rule 49 (block1 -> LBIG .)
    CONTINUE        reduce using rule 49 (block1 -> LBIG .)
    SEMICOLON       reduce using rule 49 (block1 -> LBIG .)
    error           reduce using rule 49 (block1 -> LBIG .)
    INCREMENT       reduce using rule 49 (block1 -> LBIG .)
    DECREMENT       reduce using rule 49 (block1 -> LBIG .)
    LBIG            reduce using rule 49 (block1 -> LBIG .)
    INT             reduce using rule 49 (block1 -> LBIG .)
    FLOAT           reduce using rule 49 (block1 -> LBIG .)
    BOOLEAN         reduce using rule 49 (block1 -> LBIG .)
    ID              reduce using rule 49 (block1 -> LBIG .)
    FOR             reduce using rule 49 (block1 -> LBIG .)
    THIS            reduce using rule 49 (block1 -> LBIG .)
    SUPER           reduce using rule 49 (block1 -> LBIG .)
    LPAREN          reduce using rule 49 (block1 -> LBIG .)
    INT_CONST       reduce using rule 49 (block1 -> LBIG .)
    FLOAT_CONST     reduce using rule 49 (block1 -> LBIG .)
    STRING_CONST    reduce using rule 49 (block1 -> LBIG .)
    NULL            reduce using rule 49 (block1 -> LBIG .)
    TRUE            reduce using rule 49 (block1 -> LBIG .)
    FALSE           reduce using rule 49 (block1 -> LBIG .)
    NEW             reduce using rule 49 (block1 -> LBIG .)


state 47

    (41) method_decl -> method_decl1 RPAREN block .

    RBIG            reduce using rule 41 (method_decl -> method_decl1 RPAREN block .)
    PUBLIC          reduce using rule 41 (method_decl -> method_decl1 RPAREN block .)
    PRIVATE         reduce using rule 41 (method_decl -> method_decl1 RPAREN block .)
    ID              reduce using rule 41 (method_decl -> method_decl1 RPAREN block .)
    VOID            reduce using rule 41 (method_decl -> method_decl1 RPAREN block .)
    INT             reduce using rule 41 (method_decl -> method_decl1 RPAREN block .)
    FLOAT           reduce using rule 41 (method_decl -> method_decl1 RPAREN block .)
    BOOLEAN         reduce using rule 41 (method_decl -> method_decl1 RPAREN block .)
    error           reduce using rule 41 (method_decl -> method_decl1 RPAREN block .)
    STATIC          reduce using rule 41 (method_decl -> method_decl1 RPAREN block .)


state 48

    (35) variable -> ID .

    LSQ             reduce using rule 35 (variable -> ID .)
    SEMICOLON       reduce using rule 35 (variable -> ID .)
    error           reduce using rule 35 (variable -> ID .)
    COMMA           reduce using rule 35 (variable -> ID .)
    RPAREN          reduce using rule 35 (variable -> ID .)


state 49

    (48) formal_param -> type variable .
    (36) variable -> variable . LSQ RSQ
    (37) variable -> variable . LSQ error

    RPAREN          reduce using rule 48 (formal_param -> type variable .)
    COMMA           reduce using rule 48 (formal_param -> type variable .)
    LSQ             shift and go to state 102


state 50

    (40) method_decl -> method_decl1 formals RPAREN . block
    (51) block -> . block1 RBIG
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt

    LBIG            shift and go to state 46

    block1                         shift and go to state 45
    block                          shift and go to state 103

state 51

    (47) formals -> formals COMMA . formal_param
    (48) formal_param -> . type variable
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error

    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 32
    error           shift and go to state 30

    formal_param                   shift and go to state 104
    type                           shift and go to state 31

state 52

    (39) method_decl1 -> modifier VOID ID . LPAREN

    LPAREN          shift and go to state 105


state 53

    (26) var_decl -> type variables . SEMICOLON
    (27) var_decl -> type variables . error
    (34) variables -> variables . COMMA variable

    SEMICOLON       shift and go to state 106
    error           shift and go to state 108
    COMMA           shift and go to state 107


state 54

    (33) variables -> variable .
    (36) variable -> variable . LSQ RSQ
    (37) variable -> variable . LSQ error

    SEMICOLON       reduce using rule 33 (variables -> variable .)
    error           reduce using rule 33 (variables -> variable .)
    COMMA           reduce using rule 33 (variables -> variable .)
    LSQ             shift and go to state 102


state 55

    (38) method_decl1 -> modifier type ID . LPAREN
    (35) variable -> ID .

    LPAREN          shift and go to state 109
    LSQ             reduce using rule 35 (variable -> ID .)
    SEMICOLON       reduce using rule 35 (variable -> ID .)
    error           reduce using rule 35 (variable -> ID .)
    COMMA           reduce using rule 35 (variable -> ID .)


state 56

    (42) constructor_decl -> modifier ID LPAREN . RPAREN block
    (43) constructor_decl -> modifier ID LPAREN . formals RPAREN block
    (46) formals -> . formal_param
    (47) formals -> . formals COMMA formal_param
    (48) formal_param -> . type variable
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error

    RPAREN          shift and go to state 110
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 32
    error           shift and go to state 30

    formal_param                   shift and go to state 25
    type                           shift and go to state 31
    formals                        shift and go to state 111

state 57

    (44) constructor_decl -> modifier ID error . RPAREN block
    (45) constructor_decl -> modifier ID error . formals RPAREN block
    (46) formals -> . formal_param
    (47) formals -> . formals COMMA formal_param
    (48) formal_param -> . type variable
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error

    RPAREN          shift and go to state 112
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 32
    error           shift and go to state 30

    formal_param                   shift and go to state 25
    type                           shift and go to state 31
    formals                        shift and go to state 113

state 58

    (10) class_decl1 -> CLASS error EXTENDS ID . LBIG

    LBIG            shift and go to state 114


state 59

    (7) class_decl1 -> CLASS ID EXTENDS ID . LBIG
    (13) class_decl1 -> CLASS ID EXTENDS ID . error

    LBIG            shift and go to state 115
    error           shift and go to state 116


state 60

    (8) class_decl1 -> error ID EXTENDS ID . LBIG

    LBIG            shift and go to state 117


state 61

    (67) other_stmt -> RETURN . SEMICOLON
    (68) other_stmt -> RETURN . expr SEMICOLON
    (69) other_stmt -> RETURN . error
    (70) other_stmt -> RETURN . expr error
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    SEMICOLON       shift and go to state 120
    error           shift and go to state 131
    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 128
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 62

    (100) field_access -> primary . POINT ID
    (102) array_access -> primary . LSQ expr RSQ

    POINT           shift and go to state 134
    LSQ             shift and go to state 135


state 63

    (56) noncompleteif_stmt -> WHILE . LPAREN expr RPAREN noncompleteif_stmt
    (59) other_stmt -> WHILE . LPAREN expr RPAREN other_stmt

    LPAREN          shift and go to state 136


state 64

    (81) literal -> FLOAT_CONST .

    POINT           reduce using rule 81 (literal -> FLOAT_CONST .)
    LSQ             reduce using rule 81 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 81 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 81 (literal -> FLOAT_CONST .)
    MULTI           reduce using rule 81 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 81 (literal -> FLOAT_CONST .)
    AND             reduce using rule 81 (literal -> FLOAT_CONST .)
    OR              reduce using rule 81 (literal -> FLOAT_CONST .)
    EQUAL           reduce using rule 81 (literal -> FLOAT_CONST .)
    NOTEQUAL        reduce using rule 81 (literal -> FLOAT_CONST .)
    LESS            reduce using rule 81 (literal -> FLOAT_CONST .)
    GREATER         reduce using rule 81 (literal -> FLOAT_CONST .)
    LESSEQUAL       reduce using rule 81 (literal -> FLOAT_CONST .)
    GREATEREQUAL    reduce using rule 81 (literal -> FLOAT_CONST .)
    SEMICOLON       reduce using rule 81 (literal -> FLOAT_CONST .)
    error           reduce using rule 81 (literal -> FLOAT_CONST .)
    RPAREN          reduce using rule 81 (literal -> FLOAT_CONST .)
    RSQ             reduce using rule 81 (literal -> FLOAT_CONST .)
    COMMA           reduce using rule 81 (literal -> FLOAT_CONST .)


state 65

    (90) pnew1 -> NEW . ID

    ID              shift and go to state 137


state 66

    (83) literal -> NULL .

    POINT           reduce using rule 83 (literal -> NULL .)
    LSQ             reduce using rule 83 (literal -> NULL .)
    PLUS            reduce using rule 83 (literal -> NULL .)
    MINUS           reduce using rule 83 (literal -> NULL .)
    MULTI           reduce using rule 83 (literal -> NULL .)
    DIVIDE          reduce using rule 83 (literal -> NULL .)
    AND             reduce using rule 83 (literal -> NULL .)
    OR              reduce using rule 83 (literal -> NULL .)
    EQUAL           reduce using rule 83 (literal -> NULL .)
    NOTEQUAL        reduce using rule 83 (literal -> NULL .)
    LESS            reduce using rule 83 (literal -> NULL .)
    GREATER         reduce using rule 83 (literal -> NULL .)
    LESSEQUAL       reduce using rule 83 (literal -> NULL .)
    GREATEREQUAL    reduce using rule 83 (literal -> NULL .)
    SEMICOLON       reduce using rule 83 (literal -> NULL .)
    error           reduce using rule 83 (literal -> NULL .)
    RPAREN          reduce using rule 83 (literal -> NULL .)
    RSQ             reduce using rule 83 (literal -> NULL .)
    COMMA           reduce using rule 83 (literal -> NULL .)


state 67

    (99) lhs -> array_access .

    ASSIGN          reduce using rule 99 (lhs -> array_access .)
    INCREMENT       reduce using rule 99 (lhs -> array_access .)
    DECREMENT       reduce using rule 99 (lhs -> array_access .)
    POINT           reduce using rule 99 (lhs -> array_access .)
    LSQ             reduce using rule 99 (lhs -> array_access .)
    RPAREN          reduce using rule 99 (lhs -> array_access .)
    PLUS            reduce using rule 99 (lhs -> array_access .)
    MINUS           reduce using rule 99 (lhs -> array_access .)
    MULTI           reduce using rule 99 (lhs -> array_access .)
    DIVIDE          reduce using rule 99 (lhs -> array_access .)
    AND             reduce using rule 99 (lhs -> array_access .)
    OR              reduce using rule 99 (lhs -> array_access .)
    EQUAL           reduce using rule 99 (lhs -> array_access .)
    NOTEQUAL        reduce using rule 99 (lhs -> array_access .)
    LESS            reduce using rule 99 (lhs -> array_access .)
    GREATER         reduce using rule 99 (lhs -> array_access .)
    LESSEQUAL       reduce using rule 99 (lhs -> array_access .)
    GREATEREQUAL    reduce using rule 99 (lhs -> array_access .)
    RSQ             reduce using rule 99 (lhs -> array_access .)
    SEMICOLON       reduce using rule 99 (lhs -> array_access .)
    error           reduce using rule 99 (lhs -> array_access .)
    COMMA           reduce using rule 99 (lhs -> array_access .)


state 68

    (82) literal -> STRING_CONST .

    POINT           reduce using rule 82 (literal -> STRING_CONST .)
    LSQ             reduce using rule 82 (literal -> STRING_CONST .)
    PLUS            reduce using rule 82 (literal -> STRING_CONST .)
    MINUS           reduce using rule 82 (literal -> STRING_CONST .)
    MULTI           reduce using rule 82 (literal -> STRING_CONST .)
    DIVIDE          reduce using rule 82 (literal -> STRING_CONST .)
    AND             reduce using rule 82 (literal -> STRING_CONST .)
    OR              reduce using rule 82 (literal -> STRING_CONST .)
    EQUAL           reduce using rule 82 (literal -> STRING_CONST .)
    NOTEQUAL        reduce using rule 82 (literal -> STRING_CONST .)
    LESS            reduce using rule 82 (literal -> STRING_CONST .)
    GREATER         reduce using rule 82 (literal -> STRING_CONST .)
    LESSEQUAL       reduce using rule 82 (literal -> STRING_CONST .)
    GREATEREQUAL    reduce using rule 82 (literal -> STRING_CONST .)
    SEMICOLON       reduce using rule 82 (literal -> STRING_CONST .)
    error           reduce using rule 82 (literal -> STRING_CONST .)
    RPAREN          reduce using rule 82 (literal -> STRING_CONST .)
    RSQ             reduce using rule 82 (literal -> STRING_CONST .)
    COMMA           reduce using rule 82 (literal -> STRING_CONST .)


state 69

    (80) literal -> INT_CONST .

    POINT           reduce using rule 80 (literal -> INT_CONST .)
    LSQ             reduce using rule 80 (literal -> INT_CONST .)
    PLUS            reduce using rule 80 (literal -> INT_CONST .)
    MINUS           reduce using rule 80 (literal -> INT_CONST .)
    MULTI           reduce using rule 80 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 80 (literal -> INT_CONST .)
    AND             reduce using rule 80 (literal -> INT_CONST .)
    OR              reduce using rule 80 (literal -> INT_CONST .)
    EQUAL           reduce using rule 80 (literal -> INT_CONST .)
    NOTEQUAL        reduce using rule 80 (literal -> INT_CONST .)
    LESS            reduce using rule 80 (literal -> INT_CONST .)
    GREATER         reduce using rule 80 (literal -> INT_CONST .)
    LESSEQUAL       reduce using rule 80 (literal -> INT_CONST .)
    GREATEREQUAL    reduce using rule 80 (literal -> INT_CONST .)
    SEMICOLON       reduce using rule 80 (literal -> INT_CONST .)
    error           reduce using rule 80 (literal -> INT_CONST .)
    RPAREN          reduce using rule 80 (literal -> INT_CONST .)
    RSQ             reduce using rule 80 (literal -> INT_CONST .)
    COMMA           reduce using rule 80 (literal -> INT_CONST .)


state 70

    (79) other_stmt -> SEMICOLON .

    ELSE            reduce using rule 79 (other_stmt -> SEMICOLON .)
    RBIG            reduce using rule 79 (other_stmt -> SEMICOLON .)
    IF              reduce using rule 79 (other_stmt -> SEMICOLON .)
    WHILE           reduce using rule 79 (other_stmt -> SEMICOLON .)
    RETURN          reduce using rule 79 (other_stmt -> SEMICOLON .)
    BREAK           reduce using rule 79 (other_stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 79 (other_stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 79 (other_stmt -> SEMICOLON .)
    error           reduce using rule 79 (other_stmt -> SEMICOLON .)
    INCREMENT       reduce using rule 79 (other_stmt -> SEMICOLON .)
    DECREMENT       reduce using rule 79 (other_stmt -> SEMICOLON .)
    LBIG            reduce using rule 79 (other_stmt -> SEMICOLON .)
    INT             reduce using rule 79 (other_stmt -> SEMICOLON .)
    FLOAT           reduce using rule 79 (other_stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 79 (other_stmt -> SEMICOLON .)
    ID              reduce using rule 79 (other_stmt -> SEMICOLON .)
    FOR             reduce using rule 79 (other_stmt -> SEMICOLON .)
    THIS            reduce using rule 79 (other_stmt -> SEMICOLON .)
    SUPER           reduce using rule 79 (other_stmt -> SEMICOLON .)
    LPAREN          reduce using rule 79 (other_stmt -> SEMICOLON .)
    INT_CONST       reduce using rule 79 (other_stmt -> SEMICOLON .)
    FLOAT_CONST     reduce using rule 79 (other_stmt -> SEMICOLON .)
    STRING_CONST    reduce using rule 79 (other_stmt -> SEMICOLON .)
    NULL            reduce using rule 79 (other_stmt -> SEMICOLON .)
    TRUE            reduce using rule 79 (other_stmt -> SEMICOLON .)
    FALSE           reduce using rule 79 (other_stmt -> SEMICOLON .)
    NEW             reduce using rule 79 (other_stmt -> SEMICOLON .)


state 71

    (84) literal -> TRUE .

    POINT           reduce using rule 84 (literal -> TRUE .)
    LSQ             reduce using rule 84 (literal -> TRUE .)
    PLUS            reduce using rule 84 (literal -> TRUE .)
    MINUS           reduce using rule 84 (literal -> TRUE .)
    MULTI           reduce using rule 84 (literal -> TRUE .)
    DIVIDE          reduce using rule 84 (literal -> TRUE .)
    AND             reduce using rule 84 (literal -> TRUE .)
    OR              reduce using rule 84 (literal -> TRUE .)
    EQUAL           reduce using rule 84 (literal -> TRUE .)
    NOTEQUAL        reduce using rule 84 (literal -> TRUE .)
    LESS            reduce using rule 84 (literal -> TRUE .)
    GREATER         reduce using rule 84 (literal -> TRUE .)
    LESSEQUAL       reduce using rule 84 (literal -> TRUE .)
    GREATEREQUAL    reduce using rule 84 (literal -> TRUE .)
    SEMICOLON       reduce using rule 84 (literal -> TRUE .)
    error           reduce using rule 84 (literal -> TRUE .)
    RPAREN          reduce using rule 84 (literal -> TRUE .)
    RSQ             reduce using rule 84 (literal -> TRUE .)
    COMMA           reduce using rule 84 (literal -> TRUE .)


state 72

    (86) primary -> literal .

    POINT           reduce using rule 86 (primary -> literal .)
    LSQ             reduce using rule 86 (primary -> literal .)
    PLUS            reduce using rule 86 (primary -> literal .)
    MINUS           reduce using rule 86 (primary -> literal .)
    MULTI           reduce using rule 86 (primary -> literal .)
    DIVIDE          reduce using rule 86 (primary -> literal .)
    AND             reduce using rule 86 (primary -> literal .)
    OR              reduce using rule 86 (primary -> literal .)
    EQUAL           reduce using rule 86 (primary -> literal .)
    NOTEQUAL        reduce using rule 86 (primary -> literal .)
    LESS            reduce using rule 86 (primary -> literal .)
    GREATER         reduce using rule 86 (primary -> literal .)
    LESSEQUAL       reduce using rule 86 (primary -> literal .)
    GREATEREQUAL    reduce using rule 86 (primary -> literal .)
    SEMICOLON       reduce using rule 86 (primary -> literal .)
    error           reduce using rule 86 (primary -> literal .)
    RPAREN          reduce using rule 86 (primary -> literal .)
    RSQ             reduce using rule 86 (primary -> literal .)
    COMMA           reduce using rule 86 (primary -> literal .)


state 73

    (93) primary -> pnew .

    POINT           reduce using rule 93 (primary -> pnew .)
    LSQ             reduce using rule 93 (primary -> pnew .)
    PLUS            reduce using rule 93 (primary -> pnew .)
    MINUS           reduce using rule 93 (primary -> pnew .)
    MULTI           reduce using rule 93 (primary -> pnew .)
    DIVIDE          reduce using rule 93 (primary -> pnew .)
    AND             reduce using rule 93 (primary -> pnew .)
    OR              reduce using rule 93 (primary -> pnew .)
    EQUAL           reduce using rule 93 (primary -> pnew .)
    NOTEQUAL        reduce using rule 93 (primary -> pnew .)
    LESS            reduce using rule 93 (primary -> pnew .)
    GREATER         reduce using rule 93 (primary -> pnew .)
    LESSEQUAL       reduce using rule 93 (primary -> pnew .)
    GREATEREQUAL    reduce using rule 93 (primary -> pnew .)
    SEMICOLON       reduce using rule 93 (primary -> pnew .)
    error           reduce using rule 93 (primary -> pnew .)
    RPAREN          reduce using rule 93 (primary -> pnew .)
    RSQ             reduce using rule 93 (primary -> pnew .)
    COMMA           reduce using rule 93 (primary -> pnew .)


state 74

    (71) other_stmt -> stmt_expr . SEMICOLON
    (72) other_stmt -> stmt_expr . error

    SEMICOLON       shift and go to state 138
    error           shift and go to state 139


state 75

    (57) noncompleteif_stmt -> forbasic . noncompleteif_stmt
    (66) other_stmt -> forbasic . other_stmt
    (54) noncompleteif_stmt -> . IF LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
    (56) noncompleteif_stmt -> . WHILE LPAREN expr RPAREN noncompleteif_stmt
    (57) noncompleteif_stmt -> . forbasic noncompleteif_stmt
    (58) other_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE other_stmt
    (59) other_stmt -> . WHILE LPAREN expr RPAREN other_stmt
    (66) other_stmt -> . forbasic other_stmt
    (67) other_stmt -> . RETURN SEMICOLON
    (68) other_stmt -> . RETURN expr SEMICOLON
    (69) other_stmt -> . RETURN error
    (70) other_stmt -> . RETURN expr error
    (71) other_stmt -> . stmt_expr SEMICOLON
    (72) other_stmt -> . stmt_expr error
    (73) other_stmt -> . BREAK SEMICOLON
    (74) other_stmt -> . BREAK error
    (75) other_stmt -> . CONTINUE SEMICOLON
    (76) other_stmt -> . CONTINUE error
    (77) other_stmt -> . block
    (78) other_stmt -> . var_decl
    (79) other_stmt -> . SEMICOLON
    (64) forbasic -> . forbasic2 RPAREN
    (65) forbasic -> . forbasic2 stmt_expr RPAREN
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (51) block -> . block1 RBIG
    (26) var_decl -> . type variables SEMICOLON
    (27) var_decl -> . type variables error
    (62) forbasic2 -> . forbasic1 SEMICOLON
    (63) forbasic2 -> . forbasic1 expr SEMICOLON
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error
    (60) forbasic1 -> . FOR LPAREN SEMICOLON
    (61) forbasic1 -> . FOR LPAREN stmt_expr SEMICOLON
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    IF              shift and go to state 89
    WHILE           shift and go to state 63
    RETURN          shift and go to state 61
    BREAK           shift and go to state 93
    CONTINUE        shift and go to state 95
    SEMICOLON       shift and go to state 70
    error           shift and go to state 97
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    LBIG            shift and go to state 46
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 88
    FOR             shift and go to state 80
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    block1                         shift and go to state 45
    primary                        shift and go to state 62
    array_access                   shift and go to state 67
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 74
    literal                        shift and go to state 72
    forbasic                       shift and go to state 75
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    forbasic2                      shift and go to state 82
    forbasic1                      shift and go to state 87
    noncompleteif_stmt             shift and go to state 140
    var_decl                       shift and go to state 92
    other_stmt                     shift and go to state 141
    lhs                            shift and go to state 96
    assign                         shift and go to state 100
    block                          shift and go to state 101

state 76

    (131) assign -> INCREMENT . lhs
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    ID              shift and go to state 127
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    field_access                   shift and go to state 123
    pnew1                          shift and go to state 81
    primary                        shift and go to state 62
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 142
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67

state 77

    (135) stmt_expr -> method_invocation .
    (95) primary -> method_invocation .

    SEMICOLON       reduce using rule 135 (stmt_expr -> method_invocation .)
    error           reduce using rule 135 (stmt_expr -> method_invocation .)
    RPAREN          reduce using rule 135 (stmt_expr -> method_invocation .)
    POINT           reduce using rule 95 (primary -> method_invocation .)
    LSQ             reduce using rule 95 (primary -> method_invocation .)


state 78

    (26) var_decl -> type . variables SEMICOLON
    (27) var_decl -> type . variables error
    (33) variables -> . variable
    (34) variables -> . variables COMMA variable
    (35) variable -> . ID
    (36) variable -> . variable LSQ RSQ
    (37) variable -> . variable LSQ error

    ID              shift and go to state 48

    variable                       shift and go to state 54
    variables                      shift and go to state 53

state 79

    (103) method_invocation -> field_access . LPAREN RPAREN
    (104) method_invocation -> field_access . LPAREN arguments RPAREN
    (98) lhs -> field_access .

    LPAREN          shift and go to state 143
    ASSIGN          reduce using rule 98 (lhs -> field_access .)
    INCREMENT       reduce using rule 98 (lhs -> field_access .)
    DECREMENT       reduce using rule 98 (lhs -> field_access .)
    POINT           reduce using rule 98 (lhs -> field_access .)
    LSQ             reduce using rule 98 (lhs -> field_access .)


state 80

    (60) forbasic1 -> FOR . LPAREN SEMICOLON
    (61) forbasic1 -> FOR . LPAREN stmt_expr SEMICOLON

    LPAREN          shift and go to state 144


state 81

    (91) pnew -> pnew1 . LPAREN RPAREN
    (92) pnew -> pnew1 . LPAREN arguments RPAREN

    LPAREN          shift and go to state 145


state 82

    (64) forbasic -> forbasic2 . RPAREN
    (65) forbasic -> forbasic2 . stmt_expr RPAREN
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    RPAREN          shift and go to state 146
    error           shift and go to state 148
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    ID              shift and go to state 127
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    primary                        shift and go to state 62
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 147
    literal                        shift and go to state 72
    lhs                            shift and go to state 96
    method_invocation              shift and go to state 77
    array_access                   shift and go to state 67
    assign                         shift and go to state 100

state 83

    (88) primary -> SUPER .

    POINT           reduce using rule 88 (primary -> SUPER .)
    LSQ             reduce using rule 88 (primary -> SUPER .)
    PLUS            reduce using rule 88 (primary -> SUPER .)
    MINUS           reduce using rule 88 (primary -> SUPER .)
    MULTI           reduce using rule 88 (primary -> SUPER .)
    DIVIDE          reduce using rule 88 (primary -> SUPER .)
    AND             reduce using rule 88 (primary -> SUPER .)
    OR              reduce using rule 88 (primary -> SUPER .)
    EQUAL           reduce using rule 88 (primary -> SUPER .)
    NOTEQUAL        reduce using rule 88 (primary -> SUPER .)
    LESS            reduce using rule 88 (primary -> SUPER .)
    GREATER         reduce using rule 88 (primary -> SUPER .)
    LESSEQUAL       reduce using rule 88 (primary -> SUPER .)
    GREATEREQUAL    reduce using rule 88 (primary -> SUPER .)
    SEMICOLON       reduce using rule 88 (primary -> SUPER .)
    error           reduce using rule 88 (primary -> SUPER .)
    RPAREN          reduce using rule 88 (primary -> SUPER .)
    RSQ             reduce using rule 88 (primary -> SUPER .)
    COMMA           reduce using rule 88 (primary -> SUPER .)


state 84

    (50) block1 -> block1 stmt .

    RBIG            reduce using rule 50 (block1 -> block1 stmt .)
    IF              reduce using rule 50 (block1 -> block1 stmt .)
    WHILE           reduce using rule 50 (block1 -> block1 stmt .)
    RETURN          reduce using rule 50 (block1 -> block1 stmt .)
    BREAK           reduce using rule 50 (block1 -> block1 stmt .)
    CONTINUE        reduce using rule 50 (block1 -> block1 stmt .)
    SEMICOLON       reduce using rule 50 (block1 -> block1 stmt .)
    error           reduce using rule 50 (block1 -> block1 stmt .)
    INCREMENT       reduce using rule 50 (block1 -> block1 stmt .)
    DECREMENT       reduce using rule 50 (block1 -> block1 stmt .)
    LBIG            reduce using rule 50 (block1 -> block1 stmt .)
    INT             reduce using rule 50 (block1 -> block1 stmt .)
    FLOAT           reduce using rule 50 (block1 -> block1 stmt .)
    BOOLEAN         reduce using rule 50 (block1 -> block1 stmt .)
    ID              reduce using rule 50 (block1 -> block1 stmt .)
    FOR             reduce using rule 50 (block1 -> block1 stmt .)
    THIS            reduce using rule 50 (block1 -> block1 stmt .)
    SUPER           reduce using rule 50 (block1 -> block1 stmt .)
    LPAREN          reduce using rule 50 (block1 -> block1 stmt .)
    INT_CONST       reduce using rule 50 (block1 -> block1 stmt .)
    FLOAT_CONST     reduce using rule 50 (block1 -> block1 stmt .)
    STRING_CONST    reduce using rule 50 (block1 -> block1 stmt .)
    NULL            reduce using rule 50 (block1 -> block1 stmt .)
    TRUE            reduce using rule 50 (block1 -> block1 stmt .)
    FALSE           reduce using rule 50 (block1 -> block1 stmt .)
    NEW             reduce using rule 50 (block1 -> block1 stmt .)


state 85

    (89) primary -> LPAREN . expr RPAREN
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 149
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 86

    (87) primary -> THIS .

    POINT           reduce using rule 87 (primary -> THIS .)
    LSQ             reduce using rule 87 (primary -> THIS .)
    PLUS            reduce using rule 87 (primary -> THIS .)
    MINUS           reduce using rule 87 (primary -> THIS .)
    MULTI           reduce using rule 87 (primary -> THIS .)
    DIVIDE          reduce using rule 87 (primary -> THIS .)
    AND             reduce using rule 87 (primary -> THIS .)
    OR              reduce using rule 87 (primary -> THIS .)
    EQUAL           reduce using rule 87 (primary -> THIS .)
    NOTEQUAL        reduce using rule 87 (primary -> THIS .)
    LESS            reduce using rule 87 (primary -> THIS .)
    GREATER         reduce using rule 87 (primary -> THIS .)
    LESSEQUAL       reduce using rule 87 (primary -> THIS .)
    GREATEREQUAL    reduce using rule 87 (primary -> THIS .)
    SEMICOLON       reduce using rule 87 (primary -> THIS .)
    error           reduce using rule 87 (primary -> THIS .)
    RPAREN          reduce using rule 87 (primary -> THIS .)
    RSQ             reduce using rule 87 (primary -> THIS .)
    COMMA           reduce using rule 87 (primary -> THIS .)


state 87

    (62) forbasic2 -> forbasic1 . SEMICOLON
    (63) forbasic2 -> forbasic1 . expr SEMICOLON
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    SEMICOLON       shift and go to state 150
    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 151
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 88

    (31) type -> ID .
    (101) field_access -> ID .

    ID              reduce using rule 31 (type -> ID .)
    LPAREN          reduce using rule 101 (field_access -> ID .)
    ASSIGN          reduce using rule 101 (field_access -> ID .)
    INCREMENT       reduce using rule 101 (field_access -> ID .)
    DECREMENT       reduce using rule 101 (field_access -> ID .)
    POINT           reduce using rule 101 (field_access -> ID .)
    LSQ             reduce using rule 101 (field_access -> ID .)


state 89

    (54) noncompleteif_stmt -> IF . LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> IF . LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
    (58) other_stmt -> IF . LPAREN expr RPAREN other_stmt ELSE other_stmt

    LPAREN          shift and go to state 152


state 90

    (52) stmt -> noncompleteif_stmt .

    RBIG            reduce using rule 52 (stmt -> noncompleteif_stmt .)
    IF              reduce using rule 52 (stmt -> noncompleteif_stmt .)
    WHILE           reduce using rule 52 (stmt -> noncompleteif_stmt .)
    RETURN          reduce using rule 52 (stmt -> noncompleteif_stmt .)
    BREAK           reduce using rule 52 (stmt -> noncompleteif_stmt .)
    CONTINUE        reduce using rule 52 (stmt -> noncompleteif_stmt .)
    SEMICOLON       reduce using rule 52 (stmt -> noncompleteif_stmt .)
    error           reduce using rule 52 (stmt -> noncompleteif_stmt .)
    INCREMENT       reduce using rule 52 (stmt -> noncompleteif_stmt .)
    DECREMENT       reduce using rule 52 (stmt -> noncompleteif_stmt .)
    LBIG            reduce using rule 52 (stmt -> noncompleteif_stmt .)
    INT             reduce using rule 52 (stmt -> noncompleteif_stmt .)
    FLOAT           reduce using rule 52 (stmt -> noncompleteif_stmt .)
    BOOLEAN         reduce using rule 52 (stmt -> noncompleteif_stmt .)
    ID              reduce using rule 52 (stmt -> noncompleteif_stmt .)
    FOR             reduce using rule 52 (stmt -> noncompleteif_stmt .)
    THIS            reduce using rule 52 (stmt -> noncompleteif_stmt .)
    SUPER           reduce using rule 52 (stmt -> noncompleteif_stmt .)
    LPAREN          reduce using rule 52 (stmt -> noncompleteif_stmt .)
    INT_CONST       reduce using rule 52 (stmt -> noncompleteif_stmt .)
    FLOAT_CONST     reduce using rule 52 (stmt -> noncompleteif_stmt .)
    STRING_CONST    reduce using rule 52 (stmt -> noncompleteif_stmt .)
    NULL            reduce using rule 52 (stmt -> noncompleteif_stmt .)
    TRUE            reduce using rule 52 (stmt -> noncompleteif_stmt .)
    FALSE           reduce using rule 52 (stmt -> noncompleteif_stmt .)
    NEW             reduce using rule 52 (stmt -> noncompleteif_stmt .)


state 91

    (85) literal -> FALSE .

    POINT           reduce using rule 85 (literal -> FALSE .)
    LSQ             reduce using rule 85 (literal -> FALSE .)
    PLUS            reduce using rule 85 (literal -> FALSE .)
    MINUS           reduce using rule 85 (literal -> FALSE .)
    MULTI           reduce using rule 85 (literal -> FALSE .)
    DIVIDE          reduce using rule 85 (literal -> FALSE .)
    AND             reduce using rule 85 (literal -> FALSE .)
    OR              reduce using rule 85 (literal -> FALSE .)
    EQUAL           reduce using rule 85 (literal -> FALSE .)
    NOTEQUAL        reduce using rule 85 (literal -> FALSE .)
    LESS            reduce using rule 85 (literal -> FALSE .)
    GREATER         reduce using rule 85 (literal -> FALSE .)
    LESSEQUAL       reduce using rule 85 (literal -> FALSE .)
    GREATEREQUAL    reduce using rule 85 (literal -> FALSE .)
    SEMICOLON       reduce using rule 85 (literal -> FALSE .)
    error           reduce using rule 85 (literal -> FALSE .)
    RPAREN          reduce using rule 85 (literal -> FALSE .)
    RSQ             reduce using rule 85 (literal -> FALSE .)
    COMMA           reduce using rule 85 (literal -> FALSE .)


state 92

    (78) other_stmt -> var_decl .

    ELSE            reduce using rule 78 (other_stmt -> var_decl .)
    RBIG            reduce using rule 78 (other_stmt -> var_decl .)
    IF              reduce using rule 78 (other_stmt -> var_decl .)
    WHILE           reduce using rule 78 (other_stmt -> var_decl .)
    RETURN          reduce using rule 78 (other_stmt -> var_decl .)
    BREAK           reduce using rule 78 (other_stmt -> var_decl .)
    CONTINUE        reduce using rule 78 (other_stmt -> var_decl .)
    SEMICOLON       reduce using rule 78 (other_stmt -> var_decl .)
    error           reduce using rule 78 (other_stmt -> var_decl .)
    INCREMENT       reduce using rule 78 (other_stmt -> var_decl .)
    DECREMENT       reduce using rule 78 (other_stmt -> var_decl .)
    LBIG            reduce using rule 78 (other_stmt -> var_decl .)
    INT             reduce using rule 78 (other_stmt -> var_decl .)
    FLOAT           reduce using rule 78 (other_stmt -> var_decl .)
    BOOLEAN         reduce using rule 78 (other_stmt -> var_decl .)
    ID              reduce using rule 78 (other_stmt -> var_decl .)
    FOR             reduce using rule 78 (other_stmt -> var_decl .)
    THIS            reduce using rule 78 (other_stmt -> var_decl .)
    SUPER           reduce using rule 78 (other_stmt -> var_decl .)
    LPAREN          reduce using rule 78 (other_stmt -> var_decl .)
    INT_CONST       reduce using rule 78 (other_stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 78 (other_stmt -> var_decl .)
    STRING_CONST    reduce using rule 78 (other_stmt -> var_decl .)
    NULL            reduce using rule 78 (other_stmt -> var_decl .)
    TRUE            reduce using rule 78 (other_stmt -> var_decl .)
    FALSE           reduce using rule 78 (other_stmt -> var_decl .)
    NEW             reduce using rule 78 (other_stmt -> var_decl .)


state 93

    (73) other_stmt -> BREAK . SEMICOLON
    (74) other_stmt -> BREAK . error

    SEMICOLON       shift and go to state 153
    error           shift and go to state 154


state 94

    (53) stmt -> other_stmt .

    RBIG            reduce using rule 53 (stmt -> other_stmt .)
    IF              reduce using rule 53 (stmt -> other_stmt .)
    WHILE           reduce using rule 53 (stmt -> other_stmt .)
    RETURN          reduce using rule 53 (stmt -> other_stmt .)
    BREAK           reduce using rule 53 (stmt -> other_stmt .)
    CONTINUE        reduce using rule 53 (stmt -> other_stmt .)
    SEMICOLON       reduce using rule 53 (stmt -> other_stmt .)
    error           reduce using rule 53 (stmt -> other_stmt .)
    INCREMENT       reduce using rule 53 (stmt -> other_stmt .)
    DECREMENT       reduce using rule 53 (stmt -> other_stmt .)
    LBIG            reduce using rule 53 (stmt -> other_stmt .)
    INT             reduce using rule 53 (stmt -> other_stmt .)
    FLOAT           reduce using rule 53 (stmt -> other_stmt .)
    BOOLEAN         reduce using rule 53 (stmt -> other_stmt .)
    ID              reduce using rule 53 (stmt -> other_stmt .)
    FOR             reduce using rule 53 (stmt -> other_stmt .)
    THIS            reduce using rule 53 (stmt -> other_stmt .)
    SUPER           reduce using rule 53 (stmt -> other_stmt .)
    LPAREN          reduce using rule 53 (stmt -> other_stmt .)
    INT_CONST       reduce using rule 53 (stmt -> other_stmt .)
    FLOAT_CONST     reduce using rule 53 (stmt -> other_stmt .)
    STRING_CONST    reduce using rule 53 (stmt -> other_stmt .)
    NULL            reduce using rule 53 (stmt -> other_stmt .)
    TRUE            reduce using rule 53 (stmt -> other_stmt .)
    FALSE           reduce using rule 53 (stmt -> other_stmt .)
    NEW             reduce using rule 53 (stmt -> other_stmt .)


state 95

    (75) other_stmt -> CONTINUE . SEMICOLON
    (76) other_stmt -> CONTINUE . error

    SEMICOLON       shift and go to state 155
    error           shift and go to state 156


state 96

    (129) assign -> lhs . ASSIGN expr
    (130) assign -> lhs . INCREMENT
    (132) assign -> lhs . DECREMENT
    (94) primary -> lhs .

    ASSIGN          shift and go to state 158
    INCREMENT       shift and go to state 159
    DECREMENT       shift and go to state 157
    POINT           reduce using rule 94 (primary -> lhs .)
    LSQ             reduce using rule 94 (primary -> lhs .)


state 97

    (136) stmt_expr -> error .
    (32) type -> error .

    SEMICOLON       reduce using rule 136 (stmt_expr -> error .)
    error           reduce using rule 136 (stmt_expr -> error .)
    ID              reduce using rule 32 (type -> error .)


state 98

    (133) assign -> DECREMENT . lhs
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    ID              shift and go to state 127
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    field_access                   shift and go to state 123
    pnew1                          shift and go to state 81
    primary                        shift and go to state 62
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 160
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67

state 99

    (51) block -> block1 RBIG .

    ELSE            reduce using rule 51 (block -> block1 RBIG .)
    RBIG            reduce using rule 51 (block -> block1 RBIG .)
    IF              reduce using rule 51 (block -> block1 RBIG .)
    WHILE           reduce using rule 51 (block -> block1 RBIG .)
    RETURN          reduce using rule 51 (block -> block1 RBIG .)
    BREAK           reduce using rule 51 (block -> block1 RBIG .)
    CONTINUE        reduce using rule 51 (block -> block1 RBIG .)
    SEMICOLON       reduce using rule 51 (block -> block1 RBIG .)
    error           reduce using rule 51 (block -> block1 RBIG .)
    INCREMENT       reduce using rule 51 (block -> block1 RBIG .)
    DECREMENT       reduce using rule 51 (block -> block1 RBIG .)
    LBIG            reduce using rule 51 (block -> block1 RBIG .)
    INT             reduce using rule 51 (block -> block1 RBIG .)
    FLOAT           reduce using rule 51 (block -> block1 RBIG .)
    BOOLEAN         reduce using rule 51 (block -> block1 RBIG .)
    ID              reduce using rule 51 (block -> block1 RBIG .)
    FOR             reduce using rule 51 (block -> block1 RBIG .)
    THIS            reduce using rule 51 (block -> block1 RBIG .)
    SUPER           reduce using rule 51 (block -> block1 RBIG .)
    LPAREN          reduce using rule 51 (block -> block1 RBIG .)
    INT_CONST       reduce using rule 51 (block -> block1 RBIG .)
    FLOAT_CONST     reduce using rule 51 (block -> block1 RBIG .)
    STRING_CONST    reduce using rule 51 (block -> block1 RBIG .)
    NULL            reduce using rule 51 (block -> block1 RBIG .)
    TRUE            reduce using rule 51 (block -> block1 RBIG .)
    FALSE           reduce using rule 51 (block -> block1 RBIG .)
    NEW             reduce using rule 51 (block -> block1 RBIG .)
    PUBLIC          reduce using rule 51 (block -> block1 RBIG .)
    PRIVATE         reduce using rule 51 (block -> block1 RBIG .)
    VOID            reduce using rule 51 (block -> block1 RBIG .)
    STATIC          reduce using rule 51 (block -> block1 RBIG .)


state 100

    (134) stmt_expr -> assign .

    SEMICOLON       reduce using rule 134 (stmt_expr -> assign .)
    error           reduce using rule 134 (stmt_expr -> assign .)
    RPAREN          reduce using rule 134 (stmt_expr -> assign .)


state 101

    (77) other_stmt -> block .

    ELSE            reduce using rule 77 (other_stmt -> block .)
    RBIG            reduce using rule 77 (other_stmt -> block .)
    IF              reduce using rule 77 (other_stmt -> block .)
    WHILE           reduce using rule 77 (other_stmt -> block .)
    RETURN          reduce using rule 77 (other_stmt -> block .)
    BREAK           reduce using rule 77 (other_stmt -> block .)
    CONTINUE        reduce using rule 77 (other_stmt -> block .)
    SEMICOLON       reduce using rule 77 (other_stmt -> block .)
    error           reduce using rule 77 (other_stmt -> block .)
    INCREMENT       reduce using rule 77 (other_stmt -> block .)
    DECREMENT       reduce using rule 77 (other_stmt -> block .)
    LBIG            reduce using rule 77 (other_stmt -> block .)
    INT             reduce using rule 77 (other_stmt -> block .)
    FLOAT           reduce using rule 77 (other_stmt -> block .)
    BOOLEAN         reduce using rule 77 (other_stmt -> block .)
    ID              reduce using rule 77 (other_stmt -> block .)
    FOR             reduce using rule 77 (other_stmt -> block .)
    THIS            reduce using rule 77 (other_stmt -> block .)
    SUPER           reduce using rule 77 (other_stmt -> block .)
    LPAREN          reduce using rule 77 (other_stmt -> block .)
    INT_CONST       reduce using rule 77 (other_stmt -> block .)
    FLOAT_CONST     reduce using rule 77 (other_stmt -> block .)
    STRING_CONST    reduce using rule 77 (other_stmt -> block .)
    NULL            reduce using rule 77 (other_stmt -> block .)
    TRUE            reduce using rule 77 (other_stmt -> block .)
    FALSE           reduce using rule 77 (other_stmt -> block .)
    NEW             reduce using rule 77 (other_stmt -> block .)


state 102

    (36) variable -> variable LSQ . RSQ
    (37) variable -> variable LSQ . error

    RSQ             shift and go to state 162
    error           shift and go to state 161


state 103

    (40) method_decl -> method_decl1 formals RPAREN block .

    RBIG            reduce using rule 40 (method_decl -> method_decl1 formals RPAREN block .)
    PUBLIC          reduce using rule 40 (method_decl -> method_decl1 formals RPAREN block .)
    PRIVATE         reduce using rule 40 (method_decl -> method_decl1 formals RPAREN block .)
    ID              reduce using rule 40 (method_decl -> method_decl1 formals RPAREN block .)
    VOID            reduce using rule 40 (method_decl -> method_decl1 formals RPAREN block .)
    INT             reduce using rule 40 (method_decl -> method_decl1 formals RPAREN block .)
    FLOAT           reduce using rule 40 (method_decl -> method_decl1 formals RPAREN block .)
    BOOLEAN         reduce using rule 40 (method_decl -> method_decl1 formals RPAREN block .)
    error           reduce using rule 40 (method_decl -> method_decl1 formals RPAREN block .)
    STATIC          reduce using rule 40 (method_decl -> method_decl1 formals RPAREN block .)


state 104

    (47) formals -> formals COMMA formal_param .

    RPAREN          reduce using rule 47 (formals -> formals COMMA formal_param .)
    COMMA           reduce using rule 47 (formals -> formals COMMA formal_param .)


state 105

    (39) method_decl1 -> modifier VOID ID LPAREN .

    RPAREN          reduce using rule 39 (method_decl1 -> modifier VOID ID LPAREN .)
    INT             reduce using rule 39 (method_decl1 -> modifier VOID ID LPAREN .)
    FLOAT           reduce using rule 39 (method_decl1 -> modifier VOID ID LPAREN .)
    BOOLEAN         reduce using rule 39 (method_decl1 -> modifier VOID ID LPAREN .)
    ID              reduce using rule 39 (method_decl1 -> modifier VOID ID LPAREN .)
    error           reduce using rule 39 (method_decl1 -> modifier VOID ID LPAREN .)


state 106

    (26) var_decl -> type variables SEMICOLON .

    RBIG            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    IF              reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    error           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    INCREMENT       reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    DECREMENT       reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    LBIG            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    LPAREN          reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    INT_CONST       reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    FLOAT_CONST     reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    STRING_CONST    reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 26 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 26 (var_decl -> type variables SEMICOLON .)


state 107

    (34) variables -> variables COMMA . variable
    (35) variable -> . ID
    (36) variable -> . variable LSQ RSQ
    (37) variable -> . variable LSQ error

    ID              shift and go to state 48

    variable                       shift and go to state 163

state 108

    (27) var_decl -> type variables error .

    RBIG            reduce using rule 27 (var_decl -> type variables error .)
    IF              reduce using rule 27 (var_decl -> type variables error .)
    WHILE           reduce using rule 27 (var_decl -> type variables error .)
    RETURN          reduce using rule 27 (var_decl -> type variables error .)
    BREAK           reduce using rule 27 (var_decl -> type variables error .)
    CONTINUE        reduce using rule 27 (var_decl -> type variables error .)
    SEMICOLON       reduce using rule 27 (var_decl -> type variables error .)
    error           reduce using rule 27 (var_decl -> type variables error .)
    INCREMENT       reduce using rule 27 (var_decl -> type variables error .)
    DECREMENT       reduce using rule 27 (var_decl -> type variables error .)
    LBIG            reduce using rule 27 (var_decl -> type variables error .)
    INT             reduce using rule 27 (var_decl -> type variables error .)
    FLOAT           reduce using rule 27 (var_decl -> type variables error .)
    BOOLEAN         reduce using rule 27 (var_decl -> type variables error .)
    ID              reduce using rule 27 (var_decl -> type variables error .)
    FOR             reduce using rule 27 (var_decl -> type variables error .)
    THIS            reduce using rule 27 (var_decl -> type variables error .)
    SUPER           reduce using rule 27 (var_decl -> type variables error .)
    LPAREN          reduce using rule 27 (var_decl -> type variables error .)
    INT_CONST       reduce using rule 27 (var_decl -> type variables error .)
    FLOAT_CONST     reduce using rule 27 (var_decl -> type variables error .)
    STRING_CONST    reduce using rule 27 (var_decl -> type variables error .)
    NULL            reduce using rule 27 (var_decl -> type variables error .)
    TRUE            reduce using rule 27 (var_decl -> type variables error .)
    FALSE           reduce using rule 27 (var_decl -> type variables error .)
    NEW             reduce using rule 27 (var_decl -> type variables error .)
    ELSE            reduce using rule 27 (var_decl -> type variables error .)
    PUBLIC          reduce using rule 27 (var_decl -> type variables error .)
    PRIVATE         reduce using rule 27 (var_decl -> type variables error .)
    VOID            reduce using rule 27 (var_decl -> type variables error .)
    STATIC          reduce using rule 27 (var_decl -> type variables error .)


state 109

    (38) method_decl1 -> modifier type ID LPAREN .

    RPAREN          reduce using rule 38 (method_decl1 -> modifier type ID LPAREN .)
    INT             reduce using rule 38 (method_decl1 -> modifier type ID LPAREN .)
    FLOAT           reduce using rule 38 (method_decl1 -> modifier type ID LPAREN .)
    BOOLEAN         reduce using rule 38 (method_decl1 -> modifier type ID LPAREN .)
    ID              reduce using rule 38 (method_decl1 -> modifier type ID LPAREN .)
    error           reduce using rule 38 (method_decl1 -> modifier type ID LPAREN .)


state 110

    (42) constructor_decl -> modifier ID LPAREN RPAREN . block
    (51) block -> . block1 RBIG
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt

    LBIG            shift and go to state 46

    block1                         shift and go to state 45
    block                          shift and go to state 164

state 111

    (43) constructor_decl -> modifier ID LPAREN formals . RPAREN block
    (47) formals -> formals . COMMA formal_param

    RPAREN          shift and go to state 165
    COMMA           shift and go to state 51


state 112

    (44) constructor_decl -> modifier ID error RPAREN . block
    (51) block -> . block1 RBIG
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt

    LBIG            shift and go to state 46

    block1                         shift and go to state 45
    block                          shift and go to state 166

state 113

    (45) constructor_decl -> modifier ID error formals . RPAREN block
    (47) formals -> formals . COMMA formal_param

    RPAREN          shift and go to state 167
    COMMA           shift and go to state 51


state 114

    (10) class_decl1 -> CLASS error EXTENDS ID LBIG .

    PUBLIC          reduce using rule 10 (class_decl1 -> CLASS error EXTENDS ID LBIG .)
    PRIVATE         reduce using rule 10 (class_decl1 -> CLASS error EXTENDS ID LBIG .)
    ID              reduce using rule 10 (class_decl1 -> CLASS error EXTENDS ID LBIG .)
    VOID            reduce using rule 10 (class_decl1 -> CLASS error EXTENDS ID LBIG .)
    INT             reduce using rule 10 (class_decl1 -> CLASS error EXTENDS ID LBIG .)
    FLOAT           reduce using rule 10 (class_decl1 -> CLASS error EXTENDS ID LBIG .)
    BOOLEAN         reduce using rule 10 (class_decl1 -> CLASS error EXTENDS ID LBIG .)
    error           reduce using rule 10 (class_decl1 -> CLASS error EXTENDS ID LBIG .)
    STATIC          reduce using rule 10 (class_decl1 -> CLASS error EXTENDS ID LBIG .)


state 115

    (7) class_decl1 -> CLASS ID EXTENDS ID LBIG .

    PUBLIC          reduce using rule 7 (class_decl1 -> CLASS ID EXTENDS ID LBIG .)
    PRIVATE         reduce using rule 7 (class_decl1 -> CLASS ID EXTENDS ID LBIG .)
    ID              reduce using rule 7 (class_decl1 -> CLASS ID EXTENDS ID LBIG .)
    VOID            reduce using rule 7 (class_decl1 -> CLASS ID EXTENDS ID LBIG .)
    INT             reduce using rule 7 (class_decl1 -> CLASS ID EXTENDS ID LBIG .)
    FLOAT           reduce using rule 7 (class_decl1 -> CLASS ID EXTENDS ID LBIG .)
    BOOLEAN         reduce using rule 7 (class_decl1 -> CLASS ID EXTENDS ID LBIG .)
    error           reduce using rule 7 (class_decl1 -> CLASS ID EXTENDS ID LBIG .)
    STATIC          reduce using rule 7 (class_decl1 -> CLASS ID EXTENDS ID LBIG .)


state 116

    (13) class_decl1 -> CLASS ID EXTENDS ID error .

    PUBLIC          reduce using rule 13 (class_decl1 -> CLASS ID EXTENDS ID error .)
    PRIVATE         reduce using rule 13 (class_decl1 -> CLASS ID EXTENDS ID error .)
    ID              reduce using rule 13 (class_decl1 -> CLASS ID EXTENDS ID error .)
    VOID            reduce using rule 13 (class_decl1 -> CLASS ID EXTENDS ID error .)
    INT             reduce using rule 13 (class_decl1 -> CLASS ID EXTENDS ID error .)
    FLOAT           reduce using rule 13 (class_decl1 -> CLASS ID EXTENDS ID error .)
    BOOLEAN         reduce using rule 13 (class_decl1 -> CLASS ID EXTENDS ID error .)
    error           reduce using rule 13 (class_decl1 -> CLASS ID EXTENDS ID error .)
    STATIC          reduce using rule 13 (class_decl1 -> CLASS ID EXTENDS ID error .)


state 117

    (8) class_decl1 -> error ID EXTENDS ID LBIG .

    PUBLIC          reduce using rule 8 (class_decl1 -> error ID EXTENDS ID LBIG .)
    PRIVATE         reduce using rule 8 (class_decl1 -> error ID EXTENDS ID LBIG .)
    ID              reduce using rule 8 (class_decl1 -> error ID EXTENDS ID LBIG .)
    VOID            reduce using rule 8 (class_decl1 -> error ID EXTENDS ID LBIG .)
    INT             reduce using rule 8 (class_decl1 -> error ID EXTENDS ID LBIG .)
    FLOAT           reduce using rule 8 (class_decl1 -> error ID EXTENDS ID LBIG .)
    BOOLEAN         reduce using rule 8 (class_decl1 -> error ID EXTENDS ID LBIG .)
    error           reduce using rule 8 (class_decl1 -> error ID EXTENDS ID LBIG .)
    STATIC          reduce using rule 8 (class_decl1 -> error ID EXTENDS ID LBIG .)


state 118

    (127) newarrayp -> NEW . type LSQ expr RSQ
    (90) pnew1 -> NEW . ID
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error

    ID              shift and go to state 168
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    error           shift and go to state 30

    type                           shift and go to state 169

state 119

    (120) expr -> MINUS . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 170
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 120

    (67) other_stmt -> RETURN SEMICOLON .

    ELSE            reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    RBIG            reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    error           reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    INCREMENT       reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    DECREMENT       reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    LBIG            reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    BOOLEAN         reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    ID              reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    THIS            reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    SUPER           reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    INT_CONST       reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    FLOAT_CONST     reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    STRING_CONST    reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)
    NEW             reduce using rule 67 (other_stmt -> RETURN SEMICOLON .)


state 121

    (121) expr -> PLUS . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 171
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 122

    (95) primary -> method_invocation .

    POINT           reduce using rule 95 (primary -> method_invocation .)
    LSQ             reduce using rule 95 (primary -> method_invocation .)
    PLUS            reduce using rule 95 (primary -> method_invocation .)
    MINUS           reduce using rule 95 (primary -> method_invocation .)
    MULTI           reduce using rule 95 (primary -> method_invocation .)
    DIVIDE          reduce using rule 95 (primary -> method_invocation .)
    AND             reduce using rule 95 (primary -> method_invocation .)
    OR              reduce using rule 95 (primary -> method_invocation .)
    EQUAL           reduce using rule 95 (primary -> method_invocation .)
    NOTEQUAL        reduce using rule 95 (primary -> method_invocation .)
    LESS            reduce using rule 95 (primary -> method_invocation .)
    GREATER         reduce using rule 95 (primary -> method_invocation .)
    LESSEQUAL       reduce using rule 95 (primary -> method_invocation .)
    GREATEREQUAL    reduce using rule 95 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 95 (primary -> method_invocation .)
    error           reduce using rule 95 (primary -> method_invocation .)
    RPAREN          reduce using rule 95 (primary -> method_invocation .)
    RSQ             reduce using rule 95 (primary -> method_invocation .)
    COMMA           reduce using rule 95 (primary -> method_invocation .)


state 123

    (98) lhs -> field_access .
    (103) method_invocation -> field_access . LPAREN RPAREN
    (104) method_invocation -> field_access . LPAREN arguments RPAREN

    ASSIGN          reduce using rule 98 (lhs -> field_access .)
    INCREMENT       reduce using rule 98 (lhs -> field_access .)
    DECREMENT       reduce using rule 98 (lhs -> field_access .)
    POINT           reduce using rule 98 (lhs -> field_access .)
    LSQ             reduce using rule 98 (lhs -> field_access .)
    RPAREN          reduce using rule 98 (lhs -> field_access .)
    PLUS            reduce using rule 98 (lhs -> field_access .)
    MINUS           reduce using rule 98 (lhs -> field_access .)
    MULTI           reduce using rule 98 (lhs -> field_access .)
    DIVIDE          reduce using rule 98 (lhs -> field_access .)
    AND             reduce using rule 98 (lhs -> field_access .)
    OR              reduce using rule 98 (lhs -> field_access .)
    EQUAL           reduce using rule 98 (lhs -> field_access .)
    NOTEQUAL        reduce using rule 98 (lhs -> field_access .)
    LESS            reduce using rule 98 (lhs -> field_access .)
    GREATER         reduce using rule 98 (lhs -> field_access .)
    LESSEQUAL       reduce using rule 98 (lhs -> field_access .)
    GREATEREQUAL    reduce using rule 98 (lhs -> field_access .)
    RSQ             reduce using rule 98 (lhs -> field_access .)
    SEMICOLON       reduce using rule 98 (lhs -> field_access .)
    error           reduce using rule 98 (lhs -> field_access .)
    COMMA           reduce using rule 98 (lhs -> field_access .)
    LPAREN          shift and go to state 143


state 124

    (124) newarray -> newarrayw .
    (125) newarrayw -> newarrayw . LSQ RSQ

    PLUS            reduce using rule 124 (newarray -> newarrayw .)
    MINUS           reduce using rule 124 (newarray -> newarrayw .)
    MULTI           reduce using rule 124 (newarray -> newarrayw .)
    DIVIDE          reduce using rule 124 (newarray -> newarrayw .)
    AND             reduce using rule 124 (newarray -> newarrayw .)
    OR              reduce using rule 124 (newarray -> newarrayw .)
    EQUAL           reduce using rule 124 (newarray -> newarrayw .)
    NOTEQUAL        reduce using rule 124 (newarray -> newarrayw .)
    LESS            reduce using rule 124 (newarray -> newarrayw .)
    GREATER         reduce using rule 124 (newarray -> newarrayw .)
    LESSEQUAL       reduce using rule 124 (newarray -> newarrayw .)
    GREATEREQUAL    reduce using rule 124 (newarray -> newarrayw .)
    RPAREN          reduce using rule 124 (newarray -> newarrayw .)
    COMMA           reduce using rule 124 (newarray -> newarrayw .)
    SEMICOLON       reduce using rule 124 (newarray -> newarrayw .)
    error           reduce using rule 124 (newarray -> newarrayw .)
    RSQ             reduce using rule 124 (newarray -> newarrayw .)
    LSQ             shift and go to state 172


state 125

    (123) newarray -> newarrayp .
    (128) newarrayp -> newarrayp . LSQ expr RSQ
    (126) newarrayw -> newarrayp . LSQ RSQ

    PLUS            reduce using rule 123 (newarray -> newarrayp .)
    MINUS           reduce using rule 123 (newarray -> newarrayp .)
    MULTI           reduce using rule 123 (newarray -> newarrayp .)
    DIVIDE          reduce using rule 123 (newarray -> newarrayp .)
    AND             reduce using rule 123 (newarray -> newarrayp .)
    OR              reduce using rule 123 (newarray -> newarrayp .)
    EQUAL           reduce using rule 123 (newarray -> newarrayp .)
    NOTEQUAL        reduce using rule 123 (newarray -> newarrayp .)
    LESS            reduce using rule 123 (newarray -> newarrayp .)
    GREATER         reduce using rule 123 (newarray -> newarrayp .)
    LESSEQUAL       reduce using rule 123 (newarray -> newarrayp .)
    GREATEREQUAL    reduce using rule 123 (newarray -> newarrayp .)
    RPAREN          reduce using rule 123 (newarray -> newarrayp .)
    COMMA           reduce using rule 123 (newarray -> newarrayp .)
    SEMICOLON       reduce using rule 123 (newarray -> newarrayp .)
    error           reduce using rule 123 (newarray -> newarrayp .)
    RSQ             reduce using rule 123 (newarray -> newarrayp .)
    LSQ             shift and go to state 173


state 126

    (117) expr -> primary .
    (100) field_access -> primary . POINT ID
    (102) array_access -> primary . LSQ expr RSQ

    PLUS            reduce using rule 117 (expr -> primary .)
    MINUS           reduce using rule 117 (expr -> primary .)
    MULTI           reduce using rule 117 (expr -> primary .)
    DIVIDE          reduce using rule 117 (expr -> primary .)
    AND             reduce using rule 117 (expr -> primary .)
    OR              reduce using rule 117 (expr -> primary .)
    EQUAL           reduce using rule 117 (expr -> primary .)
    NOTEQUAL        reduce using rule 117 (expr -> primary .)
    LESS            reduce using rule 117 (expr -> primary .)
    GREATER         reduce using rule 117 (expr -> primary .)
    LESSEQUAL       reduce using rule 117 (expr -> primary .)
    GREATEREQUAL    reduce using rule 117 (expr -> primary .)
    SEMICOLON       reduce using rule 117 (expr -> primary .)
    error           reduce using rule 117 (expr -> primary .)
    RPAREN          reduce using rule 117 (expr -> primary .)
    RSQ             reduce using rule 117 (expr -> primary .)
    COMMA           reduce using rule 117 (expr -> primary .)
    POINT           shift and go to state 134
    LSQ             shift and go to state 135


state 127

    (101) field_access -> ID .

    LPAREN          reduce using rule 101 (field_access -> ID .)
    ASSIGN          reduce using rule 101 (field_access -> ID .)
    INCREMENT       reduce using rule 101 (field_access -> ID .)
    DECREMENT       reduce using rule 101 (field_access -> ID .)
    POINT           reduce using rule 101 (field_access -> ID .)
    LSQ             reduce using rule 101 (field_access -> ID .)
    PLUS            reduce using rule 101 (field_access -> ID .)
    MINUS           reduce using rule 101 (field_access -> ID .)
    MULTI           reduce using rule 101 (field_access -> ID .)
    DIVIDE          reduce using rule 101 (field_access -> ID .)
    AND             reduce using rule 101 (field_access -> ID .)
    OR              reduce using rule 101 (field_access -> ID .)
    EQUAL           reduce using rule 101 (field_access -> ID .)
    NOTEQUAL        reduce using rule 101 (field_access -> ID .)
    LESS            reduce using rule 101 (field_access -> ID .)
    GREATER         reduce using rule 101 (field_access -> ID .)
    LESSEQUAL       reduce using rule 101 (field_access -> ID .)
    GREATEREQUAL    reduce using rule 101 (field_access -> ID .)
    RPAREN          reduce using rule 101 (field_access -> ID .)
    COMMA           reduce using rule 101 (field_access -> ID .)
    SEMICOLON       reduce using rule 101 (field_access -> ID .)
    error           reduce using rule 101 (field_access -> ID .)
    RSQ             reduce using rule 101 (field_access -> ID .)


state 128

    (68) other_stmt -> RETURN expr . SEMICOLON
    (70) other_stmt -> RETURN expr . error
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    SEMICOLON       shift and go to state 178
    error           shift and go to state 184
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 129

    (94) primary -> lhs .
    (129) assign -> lhs . ASSIGN expr
    (130) assign -> lhs . INCREMENT
    (132) assign -> lhs . DECREMENT

    POINT           reduce using rule 94 (primary -> lhs .)
    LSQ             reduce using rule 94 (primary -> lhs .)
    PLUS            reduce using rule 94 (primary -> lhs .)
    MINUS           reduce using rule 94 (primary -> lhs .)
    MULTI           reduce using rule 94 (primary -> lhs .)
    DIVIDE          reduce using rule 94 (primary -> lhs .)
    AND             reduce using rule 94 (primary -> lhs .)
    OR              reduce using rule 94 (primary -> lhs .)
    EQUAL           reduce using rule 94 (primary -> lhs .)
    NOTEQUAL        reduce using rule 94 (primary -> lhs .)
    LESS            reduce using rule 94 (primary -> lhs .)
    GREATER         reduce using rule 94 (primary -> lhs .)
    LESSEQUAL       reduce using rule 94 (primary -> lhs .)
    GREATEREQUAL    reduce using rule 94 (primary -> lhs .)
    SEMICOLON       reduce using rule 94 (primary -> lhs .)
    error           reduce using rule 94 (primary -> lhs .)
    RPAREN          reduce using rule 94 (primary -> lhs .)
    RSQ             reduce using rule 94 (primary -> lhs .)
    COMMA           reduce using rule 94 (primary -> lhs .)
    ASSIGN          shift and go to state 158
    INCREMENT       shift and go to state 159
    DECREMENT       shift and go to state 157


state 130

    (119) expr -> newarray .

    PLUS            reduce using rule 119 (expr -> newarray .)
    MINUS           reduce using rule 119 (expr -> newarray .)
    MULTI           reduce using rule 119 (expr -> newarray .)
    DIVIDE          reduce using rule 119 (expr -> newarray .)
    AND             reduce using rule 119 (expr -> newarray .)
    OR              reduce using rule 119 (expr -> newarray .)
    EQUAL           reduce using rule 119 (expr -> newarray .)
    NOTEQUAL        reduce using rule 119 (expr -> newarray .)
    LESS            reduce using rule 119 (expr -> newarray .)
    GREATER         reduce using rule 119 (expr -> newarray .)
    LESSEQUAL       reduce using rule 119 (expr -> newarray .)
    GREATEREQUAL    reduce using rule 119 (expr -> newarray .)
    SEMICOLON       reduce using rule 119 (expr -> newarray .)
    error           reduce using rule 119 (expr -> newarray .)
    RPAREN          reduce using rule 119 (expr -> newarray .)
    RSQ             reduce using rule 119 (expr -> newarray .)
    COMMA           reduce using rule 119 (expr -> newarray .)


state 131

    (69) other_stmt -> RETURN error .

    ELSE            reduce using rule 69 (other_stmt -> RETURN error .)
    RBIG            reduce using rule 69 (other_stmt -> RETURN error .)
    IF              reduce using rule 69 (other_stmt -> RETURN error .)
    WHILE           reduce using rule 69 (other_stmt -> RETURN error .)
    RETURN          reduce using rule 69 (other_stmt -> RETURN error .)
    BREAK           reduce using rule 69 (other_stmt -> RETURN error .)
    CONTINUE        reduce using rule 69 (other_stmt -> RETURN error .)
    SEMICOLON       reduce using rule 69 (other_stmt -> RETURN error .)
    error           reduce using rule 69 (other_stmt -> RETURN error .)
    INCREMENT       reduce using rule 69 (other_stmt -> RETURN error .)
    DECREMENT       reduce using rule 69 (other_stmt -> RETURN error .)
    LBIG            reduce using rule 69 (other_stmt -> RETURN error .)
    INT             reduce using rule 69 (other_stmt -> RETURN error .)
    FLOAT           reduce using rule 69 (other_stmt -> RETURN error .)
    BOOLEAN         reduce using rule 69 (other_stmt -> RETURN error .)
    ID              reduce using rule 69 (other_stmt -> RETURN error .)
    FOR             reduce using rule 69 (other_stmt -> RETURN error .)
    THIS            reduce using rule 69 (other_stmt -> RETURN error .)
    SUPER           reduce using rule 69 (other_stmt -> RETURN error .)
    LPAREN          reduce using rule 69 (other_stmt -> RETURN error .)
    INT_CONST       reduce using rule 69 (other_stmt -> RETURN error .)
    FLOAT_CONST     reduce using rule 69 (other_stmt -> RETURN error .)
    STRING_CONST    reduce using rule 69 (other_stmt -> RETURN error .)
    NULL            reduce using rule 69 (other_stmt -> RETURN error .)
    TRUE            reduce using rule 69 (other_stmt -> RETURN error .)
    FALSE           reduce using rule 69 (other_stmt -> RETURN error .)
    NEW             reduce using rule 69 (other_stmt -> RETURN error .)


state 132

    (122) expr -> NOT . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 188
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 133

    (118) expr -> assign .

    PLUS            reduce using rule 118 (expr -> assign .)
    MINUS           reduce using rule 118 (expr -> assign .)
    MULTI           reduce using rule 118 (expr -> assign .)
    DIVIDE          reduce using rule 118 (expr -> assign .)
    AND             reduce using rule 118 (expr -> assign .)
    OR              reduce using rule 118 (expr -> assign .)
    EQUAL           reduce using rule 118 (expr -> assign .)
    NOTEQUAL        reduce using rule 118 (expr -> assign .)
    LESS            reduce using rule 118 (expr -> assign .)
    GREATER         reduce using rule 118 (expr -> assign .)
    LESSEQUAL       reduce using rule 118 (expr -> assign .)
    GREATEREQUAL    reduce using rule 118 (expr -> assign .)
    SEMICOLON       reduce using rule 118 (expr -> assign .)
    error           reduce using rule 118 (expr -> assign .)
    RPAREN          reduce using rule 118 (expr -> assign .)
    RSQ             reduce using rule 118 (expr -> assign .)
    COMMA           reduce using rule 118 (expr -> assign .)


state 134

    (100) field_access -> primary POINT . ID

    ID              shift and go to state 189


state 135

    (102) array_access -> primary LSQ . expr RSQ
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 190
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 136

    (56) noncompleteif_stmt -> WHILE LPAREN . expr RPAREN noncompleteif_stmt
    (59) other_stmt -> WHILE LPAREN . expr RPAREN other_stmt
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    field_access                   shift and go to state 123
    expr                           shift and go to state 191
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    newarrayp                      shift and go to state 125
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 137

    (90) pnew1 -> NEW ID .

    LPAREN          reduce using rule 90 (pnew1 -> NEW ID .)


state 138

    (71) other_stmt -> stmt_expr SEMICOLON .

    ELSE            reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    RBIG            reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    IF              reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    WHILE           reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    RETURN          reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    BREAK           reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    CONTINUE        reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    SEMICOLON       reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    error           reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    INCREMENT       reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    DECREMENT       reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    LBIG            reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    INT             reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    FLOAT           reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    BOOLEAN         reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    ID              reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    FOR             reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    THIS            reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    SUPER           reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    LPAREN          reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    INT_CONST       reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    STRING_CONST    reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    NULL            reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    TRUE            reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    FALSE           reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)
    NEW             reduce using rule 71 (other_stmt -> stmt_expr SEMICOLON .)


state 139

    (72) other_stmt -> stmt_expr error .

    ELSE            reduce using rule 72 (other_stmt -> stmt_expr error .)
    RBIG            reduce using rule 72 (other_stmt -> stmt_expr error .)
    IF              reduce using rule 72 (other_stmt -> stmt_expr error .)
    WHILE           reduce using rule 72 (other_stmt -> stmt_expr error .)
    RETURN          reduce using rule 72 (other_stmt -> stmt_expr error .)
    BREAK           reduce using rule 72 (other_stmt -> stmt_expr error .)
    CONTINUE        reduce using rule 72 (other_stmt -> stmt_expr error .)
    SEMICOLON       reduce using rule 72 (other_stmt -> stmt_expr error .)
    error           reduce using rule 72 (other_stmt -> stmt_expr error .)
    INCREMENT       reduce using rule 72 (other_stmt -> stmt_expr error .)
    DECREMENT       reduce using rule 72 (other_stmt -> stmt_expr error .)
    LBIG            reduce using rule 72 (other_stmt -> stmt_expr error .)
    INT             reduce using rule 72 (other_stmt -> stmt_expr error .)
    FLOAT           reduce using rule 72 (other_stmt -> stmt_expr error .)
    BOOLEAN         reduce using rule 72 (other_stmt -> stmt_expr error .)
    ID              reduce using rule 72 (other_stmt -> stmt_expr error .)
    FOR             reduce using rule 72 (other_stmt -> stmt_expr error .)
    THIS            reduce using rule 72 (other_stmt -> stmt_expr error .)
    SUPER           reduce using rule 72 (other_stmt -> stmt_expr error .)
    LPAREN          reduce using rule 72 (other_stmt -> stmt_expr error .)
    INT_CONST       reduce using rule 72 (other_stmt -> stmt_expr error .)
    FLOAT_CONST     reduce using rule 72 (other_stmt -> stmt_expr error .)
    STRING_CONST    reduce using rule 72 (other_stmt -> stmt_expr error .)
    NULL            reduce using rule 72 (other_stmt -> stmt_expr error .)
    TRUE            reduce using rule 72 (other_stmt -> stmt_expr error .)
    FALSE           reduce using rule 72 (other_stmt -> stmt_expr error .)
    NEW             reduce using rule 72 (other_stmt -> stmt_expr error .)


state 140

    (57) noncompleteif_stmt -> forbasic noncompleteif_stmt .

    RBIG            reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    IF              reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    WHILE           reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    RETURN          reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    BREAK           reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    CONTINUE        reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    SEMICOLON       reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    error           reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    INCREMENT       reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    DECREMENT       reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    LBIG            reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    INT             reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    FLOAT           reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    BOOLEAN         reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    ID              reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    FOR             reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    THIS            reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    SUPER           reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    LPAREN          reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    INT_CONST       reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    FLOAT_CONST     reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    STRING_CONST    reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    NULL            reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    TRUE            reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    FALSE           reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)
    NEW             reduce using rule 57 (noncompleteif_stmt -> forbasic noncompleteif_stmt .)


state 141

    (66) other_stmt -> forbasic other_stmt .

    ELSE            reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    RBIG            reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    IF              reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    WHILE           reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    RETURN          reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    BREAK           reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    CONTINUE        reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    SEMICOLON       reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    error           reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    INCREMENT       reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    DECREMENT       reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    LBIG            reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    INT             reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    FLOAT           reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    BOOLEAN         reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    ID              reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    FOR             reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    THIS            reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    SUPER           reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    LPAREN          reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    INT_CONST       reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    FLOAT_CONST     reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    STRING_CONST    reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    NULL            reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    TRUE            reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    FALSE           reduce using rule 66 (other_stmt -> forbasic other_stmt .)
    NEW             reduce using rule 66 (other_stmt -> forbasic other_stmt .)


state 142

    (131) assign -> INCREMENT lhs .
    (94) primary -> lhs .

    RPAREN          reduce using rule 131 (assign -> INCREMENT lhs .)
    PLUS            reduce using rule 131 (assign -> INCREMENT lhs .)
    MINUS           reduce using rule 131 (assign -> INCREMENT lhs .)
    MULTI           reduce using rule 131 (assign -> INCREMENT lhs .)
    DIVIDE          reduce using rule 131 (assign -> INCREMENT lhs .)
    AND             reduce using rule 131 (assign -> INCREMENT lhs .)
    OR              reduce using rule 131 (assign -> INCREMENT lhs .)
    EQUAL           reduce using rule 131 (assign -> INCREMENT lhs .)
    NOTEQUAL        reduce using rule 131 (assign -> INCREMENT lhs .)
    LESS            reduce using rule 131 (assign -> INCREMENT lhs .)
    GREATER         reduce using rule 131 (assign -> INCREMENT lhs .)
    LESSEQUAL       reduce using rule 131 (assign -> INCREMENT lhs .)
    GREATEREQUAL    reduce using rule 131 (assign -> INCREMENT lhs .)
    SEMICOLON       reduce using rule 131 (assign -> INCREMENT lhs .)
    error           reduce using rule 131 (assign -> INCREMENT lhs .)
    RSQ             reduce using rule 131 (assign -> INCREMENT lhs .)
    COMMA           reduce using rule 131 (assign -> INCREMENT lhs .)
    POINT           reduce using rule 94 (primary -> lhs .)
    LSQ             reduce using rule 94 (primary -> lhs .)


state 143

    (103) method_invocation -> field_access LPAREN . RPAREN
    (104) method_invocation -> field_access LPAREN . arguments RPAREN
    (96) arguments -> . expr
    (97) arguments -> . arguments COMMA expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    RPAREN          shift and go to state 192
    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 194
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    arguments                      shift and go to state 193
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133
    newarray                       shift and go to state 130

state 144

    (60) forbasic1 -> FOR LPAREN . SEMICOLON
    (61) forbasic1 -> FOR LPAREN . stmt_expr SEMICOLON
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    SEMICOLON       shift and go to state 195
    error           shift and go to state 148
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    ID              shift and go to state 127
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    primary                        shift and go to state 62
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 196
    literal                        shift and go to state 72
    lhs                            shift and go to state 96
    method_invocation              shift and go to state 77
    array_access                   shift and go to state 67
    assign                         shift and go to state 100

state 145

    (91) pnew -> pnew1 LPAREN . RPAREN
    (92) pnew -> pnew1 LPAREN . arguments RPAREN
    (96) arguments -> . expr
    (97) arguments -> . arguments COMMA expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    RPAREN          shift and go to state 197
    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 194
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    arguments                      shift and go to state 198
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133
    newarray                       shift and go to state 130

state 146

    (64) forbasic -> forbasic2 RPAREN .

    IF              reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    WHILE           reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    RETURN          reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    BREAK           reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    CONTINUE        reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    SEMICOLON       reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    error           reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    INCREMENT       reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    DECREMENT       reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    LBIG            reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    INT             reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    FLOAT           reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    BOOLEAN         reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    ID              reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    FOR             reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    THIS            reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    SUPER           reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    LPAREN          reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    INT_CONST       reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    FLOAT_CONST     reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    STRING_CONST    reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    NULL            reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    TRUE            reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    FALSE           reduce using rule 64 (forbasic -> forbasic2 RPAREN .)
    NEW             reduce using rule 64 (forbasic -> forbasic2 RPAREN .)


state 147

    (65) forbasic -> forbasic2 stmt_expr . RPAREN

    RPAREN          shift and go to state 199


state 148

    (136) stmt_expr -> error .

    RPAREN          reduce using rule 136 (stmt_expr -> error .)
    SEMICOLON       reduce using rule 136 (stmt_expr -> error .)


state 149

    (89) primary -> LPAREN expr . RPAREN
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RPAREN          shift and go to state 200
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 150

    (62) forbasic2 -> forbasic1 SEMICOLON .

    RPAREN          reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    error           reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    INCREMENT       reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    DECREMENT       reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    ID              reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    THIS            reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    SUPER           reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    LPAREN          reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    INT_CONST       reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    FLOAT_CONST     reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    STRING_CONST    reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    NULL            reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    TRUE            reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    FALSE           reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)
    NEW             reduce using rule 62 (forbasic2 -> forbasic1 SEMICOLON .)


state 151

    (63) forbasic2 -> forbasic1 expr . SEMICOLON
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    SEMICOLON       shift and go to state 201
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 152

    (54) noncompleteif_stmt -> IF LPAREN . expr RPAREN stmt
    (55) noncompleteif_stmt -> IF LPAREN . expr RPAREN other_stmt ELSE noncompleteif_stmt
    (58) other_stmt -> IF LPAREN . expr RPAREN other_stmt ELSE other_stmt
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    field_access                   shift and go to state 123
    pnew                           shift and go to state 73
    expr                           shift and go to state 202
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    newarrayp                      shift and go to state 125
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 153

    (73) other_stmt -> BREAK SEMICOLON .

    ELSE            reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    RBIG            reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    error           reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    LBIG            reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    INT_CONST       reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    FLOAT_CONST     reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    STRING_CONST    reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 73 (other_stmt -> BREAK SEMICOLON .)


state 154

    (74) other_stmt -> BREAK error .

    ELSE            reduce using rule 74 (other_stmt -> BREAK error .)
    RBIG            reduce using rule 74 (other_stmt -> BREAK error .)
    IF              reduce using rule 74 (other_stmt -> BREAK error .)
    WHILE           reduce using rule 74 (other_stmt -> BREAK error .)
    RETURN          reduce using rule 74 (other_stmt -> BREAK error .)
    BREAK           reduce using rule 74 (other_stmt -> BREAK error .)
    CONTINUE        reduce using rule 74 (other_stmt -> BREAK error .)
    SEMICOLON       reduce using rule 74 (other_stmt -> BREAK error .)
    error           reduce using rule 74 (other_stmt -> BREAK error .)
    INCREMENT       reduce using rule 74 (other_stmt -> BREAK error .)
    DECREMENT       reduce using rule 74 (other_stmt -> BREAK error .)
    LBIG            reduce using rule 74 (other_stmt -> BREAK error .)
    INT             reduce using rule 74 (other_stmt -> BREAK error .)
    FLOAT           reduce using rule 74 (other_stmt -> BREAK error .)
    BOOLEAN         reduce using rule 74 (other_stmt -> BREAK error .)
    ID              reduce using rule 74 (other_stmt -> BREAK error .)
    FOR             reduce using rule 74 (other_stmt -> BREAK error .)
    THIS            reduce using rule 74 (other_stmt -> BREAK error .)
    SUPER           reduce using rule 74 (other_stmt -> BREAK error .)
    LPAREN          reduce using rule 74 (other_stmt -> BREAK error .)
    INT_CONST       reduce using rule 74 (other_stmt -> BREAK error .)
    FLOAT_CONST     reduce using rule 74 (other_stmt -> BREAK error .)
    STRING_CONST    reduce using rule 74 (other_stmt -> BREAK error .)
    NULL            reduce using rule 74 (other_stmt -> BREAK error .)
    TRUE            reduce using rule 74 (other_stmt -> BREAK error .)
    FALSE           reduce using rule 74 (other_stmt -> BREAK error .)
    NEW             reduce using rule 74 (other_stmt -> BREAK error .)


state 155

    (75) other_stmt -> CONTINUE SEMICOLON .

    ELSE            reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    RBIG            reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    error           reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    INCREMENT       reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    DECREMENT       reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    LBIG            reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    INT_CONST       reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    FLOAT_CONST     reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    STRING_CONST    reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 75 (other_stmt -> CONTINUE SEMICOLON .)


state 156

    (76) other_stmt -> CONTINUE error .

    ELSE            reduce using rule 76 (other_stmt -> CONTINUE error .)
    RBIG            reduce using rule 76 (other_stmt -> CONTINUE error .)
    IF              reduce using rule 76 (other_stmt -> CONTINUE error .)
    WHILE           reduce using rule 76 (other_stmt -> CONTINUE error .)
    RETURN          reduce using rule 76 (other_stmt -> CONTINUE error .)
    BREAK           reduce using rule 76 (other_stmt -> CONTINUE error .)
    CONTINUE        reduce using rule 76 (other_stmt -> CONTINUE error .)
    SEMICOLON       reduce using rule 76 (other_stmt -> CONTINUE error .)
    error           reduce using rule 76 (other_stmt -> CONTINUE error .)
    INCREMENT       reduce using rule 76 (other_stmt -> CONTINUE error .)
    DECREMENT       reduce using rule 76 (other_stmt -> CONTINUE error .)
    LBIG            reduce using rule 76 (other_stmt -> CONTINUE error .)
    INT             reduce using rule 76 (other_stmt -> CONTINUE error .)
    FLOAT           reduce using rule 76 (other_stmt -> CONTINUE error .)
    BOOLEAN         reduce using rule 76 (other_stmt -> CONTINUE error .)
    ID              reduce using rule 76 (other_stmt -> CONTINUE error .)
    FOR             reduce using rule 76 (other_stmt -> CONTINUE error .)
    THIS            reduce using rule 76 (other_stmt -> CONTINUE error .)
    SUPER           reduce using rule 76 (other_stmt -> CONTINUE error .)
    LPAREN          reduce using rule 76 (other_stmt -> CONTINUE error .)
    INT_CONST       reduce using rule 76 (other_stmt -> CONTINUE error .)
    FLOAT_CONST     reduce using rule 76 (other_stmt -> CONTINUE error .)
    STRING_CONST    reduce using rule 76 (other_stmt -> CONTINUE error .)
    NULL            reduce using rule 76 (other_stmt -> CONTINUE error .)
    TRUE            reduce using rule 76 (other_stmt -> CONTINUE error .)
    FALSE           reduce using rule 76 (other_stmt -> CONTINUE error .)
    NEW             reduce using rule 76 (other_stmt -> CONTINUE error .)


state 157

    (132) assign -> lhs DECREMENT .

    RPAREN          reduce using rule 132 (assign -> lhs DECREMENT .)
    PLUS            reduce using rule 132 (assign -> lhs DECREMENT .)
    MINUS           reduce using rule 132 (assign -> lhs DECREMENT .)
    MULTI           reduce using rule 132 (assign -> lhs DECREMENT .)
    DIVIDE          reduce using rule 132 (assign -> lhs DECREMENT .)
    AND             reduce using rule 132 (assign -> lhs DECREMENT .)
    OR              reduce using rule 132 (assign -> lhs DECREMENT .)
    EQUAL           reduce using rule 132 (assign -> lhs DECREMENT .)
    NOTEQUAL        reduce using rule 132 (assign -> lhs DECREMENT .)
    LESS            reduce using rule 132 (assign -> lhs DECREMENT .)
    GREATER         reduce using rule 132 (assign -> lhs DECREMENT .)
    LESSEQUAL       reduce using rule 132 (assign -> lhs DECREMENT .)
    GREATEREQUAL    reduce using rule 132 (assign -> lhs DECREMENT .)
    SEMICOLON       reduce using rule 132 (assign -> lhs DECREMENT .)
    error           reduce using rule 132 (assign -> lhs DECREMENT .)
    RSQ             reduce using rule 132 (assign -> lhs DECREMENT .)
    COMMA           reduce using rule 132 (assign -> lhs DECREMENT .)


state 158

    (129) assign -> lhs ASSIGN . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 203
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 159

    (130) assign -> lhs INCREMENT .

    RPAREN          reduce using rule 130 (assign -> lhs INCREMENT .)
    PLUS            reduce using rule 130 (assign -> lhs INCREMENT .)
    MINUS           reduce using rule 130 (assign -> lhs INCREMENT .)
    MULTI           reduce using rule 130 (assign -> lhs INCREMENT .)
    DIVIDE          reduce using rule 130 (assign -> lhs INCREMENT .)
    AND             reduce using rule 130 (assign -> lhs INCREMENT .)
    OR              reduce using rule 130 (assign -> lhs INCREMENT .)
    EQUAL           reduce using rule 130 (assign -> lhs INCREMENT .)
    NOTEQUAL        reduce using rule 130 (assign -> lhs INCREMENT .)
    LESS            reduce using rule 130 (assign -> lhs INCREMENT .)
    GREATER         reduce using rule 130 (assign -> lhs INCREMENT .)
    LESSEQUAL       reduce using rule 130 (assign -> lhs INCREMENT .)
    GREATEREQUAL    reduce using rule 130 (assign -> lhs INCREMENT .)
    SEMICOLON       reduce using rule 130 (assign -> lhs INCREMENT .)
    error           reduce using rule 130 (assign -> lhs INCREMENT .)
    RSQ             reduce using rule 130 (assign -> lhs INCREMENT .)
    COMMA           reduce using rule 130 (assign -> lhs INCREMENT .)


state 160

    (133) assign -> DECREMENT lhs .
    (94) primary -> lhs .

    RPAREN          reduce using rule 133 (assign -> DECREMENT lhs .)
    PLUS            reduce using rule 133 (assign -> DECREMENT lhs .)
    MINUS           reduce using rule 133 (assign -> DECREMENT lhs .)
    MULTI           reduce using rule 133 (assign -> DECREMENT lhs .)
    DIVIDE          reduce using rule 133 (assign -> DECREMENT lhs .)
    AND             reduce using rule 133 (assign -> DECREMENT lhs .)
    OR              reduce using rule 133 (assign -> DECREMENT lhs .)
    EQUAL           reduce using rule 133 (assign -> DECREMENT lhs .)
    NOTEQUAL        reduce using rule 133 (assign -> DECREMENT lhs .)
    LESS            reduce using rule 133 (assign -> DECREMENT lhs .)
    GREATER         reduce using rule 133 (assign -> DECREMENT lhs .)
    LESSEQUAL       reduce using rule 133 (assign -> DECREMENT lhs .)
    GREATEREQUAL    reduce using rule 133 (assign -> DECREMENT lhs .)
    SEMICOLON       reduce using rule 133 (assign -> DECREMENT lhs .)
    error           reduce using rule 133 (assign -> DECREMENT lhs .)
    RSQ             reduce using rule 133 (assign -> DECREMENT lhs .)
    COMMA           reduce using rule 133 (assign -> DECREMENT lhs .)
    POINT           reduce using rule 94 (primary -> lhs .)
    LSQ             reduce using rule 94 (primary -> lhs .)


state 161

    (37) variable -> variable LSQ error .

    LSQ             reduce using rule 37 (variable -> variable LSQ error .)
    SEMICOLON       reduce using rule 37 (variable -> variable LSQ error .)
    error           reduce using rule 37 (variable -> variable LSQ error .)
    COMMA           reduce using rule 37 (variable -> variable LSQ error .)
    RPAREN          reduce using rule 37 (variable -> variable LSQ error .)


state 162

    (36) variable -> variable LSQ RSQ .

    LSQ             reduce using rule 36 (variable -> variable LSQ RSQ .)
    SEMICOLON       reduce using rule 36 (variable -> variable LSQ RSQ .)
    error           reduce using rule 36 (variable -> variable LSQ RSQ .)
    COMMA           reduce using rule 36 (variable -> variable LSQ RSQ .)
    RPAREN          reduce using rule 36 (variable -> variable LSQ RSQ .)


state 163

    (34) variables -> variables COMMA variable .
    (36) variable -> variable . LSQ RSQ
    (37) variable -> variable . LSQ error

    SEMICOLON       reduce using rule 34 (variables -> variables COMMA variable .)
    error           reduce using rule 34 (variables -> variables COMMA variable .)
    COMMA           reduce using rule 34 (variables -> variables COMMA variable .)
    LSQ             shift and go to state 102


state 164

    (42) constructor_decl -> modifier ID LPAREN RPAREN block .

    RBIG            reduce using rule 42 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 42 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 42 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    ID              reduce using rule 42 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    VOID            reduce using rule 42 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    INT             reduce using rule 42 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 42 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 42 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    error           reduce using rule 42 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    STATIC          reduce using rule 42 (constructor_decl -> modifier ID LPAREN RPAREN block .)


state 165

    (43) constructor_decl -> modifier ID LPAREN formals RPAREN . block
    (51) block -> . block1 RBIG
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt

    LBIG            shift and go to state 46

    block1                         shift and go to state 45
    block                          shift and go to state 204

state 166

    (44) constructor_decl -> modifier ID error RPAREN block .

    RBIG            reduce using rule 44 (constructor_decl -> modifier ID error RPAREN block .)
    PUBLIC          reduce using rule 44 (constructor_decl -> modifier ID error RPAREN block .)
    PRIVATE         reduce using rule 44 (constructor_decl -> modifier ID error RPAREN block .)
    ID              reduce using rule 44 (constructor_decl -> modifier ID error RPAREN block .)
    VOID            reduce using rule 44 (constructor_decl -> modifier ID error RPAREN block .)
    INT             reduce using rule 44 (constructor_decl -> modifier ID error RPAREN block .)
    FLOAT           reduce using rule 44 (constructor_decl -> modifier ID error RPAREN block .)
    BOOLEAN         reduce using rule 44 (constructor_decl -> modifier ID error RPAREN block .)
    error           reduce using rule 44 (constructor_decl -> modifier ID error RPAREN block .)
    STATIC          reduce using rule 44 (constructor_decl -> modifier ID error RPAREN block .)


state 167

    (45) constructor_decl -> modifier ID error formals RPAREN . block
    (51) block -> . block1 RBIG
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt

    LBIG            shift and go to state 46

    block1                         shift and go to state 45
    block                          shift and go to state 205

state 168

    (90) pnew1 -> NEW ID .
    (31) type -> ID .

    LPAREN          reduce using rule 90 (pnew1 -> NEW ID .)
    LSQ             reduce using rule 31 (type -> ID .)


state 169

    (127) newarrayp -> NEW type . LSQ expr RSQ

    LSQ             shift and go to state 206


state 170

    (120) expr -> MINUS expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    PLUS            reduce using rule 120 (expr -> MINUS expr .)
    MINUS           reduce using rule 120 (expr -> MINUS expr .)
    MULTI           reduce using rule 120 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 120 (expr -> MINUS expr .)
    AND             reduce using rule 120 (expr -> MINUS expr .)
    OR              reduce using rule 120 (expr -> MINUS expr .)
    EQUAL           reduce using rule 120 (expr -> MINUS expr .)
    NOTEQUAL        reduce using rule 120 (expr -> MINUS expr .)
    LESS            reduce using rule 120 (expr -> MINUS expr .)
    GREATER         reduce using rule 120 (expr -> MINUS expr .)
    LESSEQUAL       reduce using rule 120 (expr -> MINUS expr .)
    GREATEREQUAL    reduce using rule 120 (expr -> MINUS expr .)
    SEMICOLON       reduce using rule 120 (expr -> MINUS expr .)
    error           reduce using rule 120 (expr -> MINUS expr .)
    RPAREN          reduce using rule 120 (expr -> MINUS expr .)
    RSQ             reduce using rule 120 (expr -> MINUS expr .)
    COMMA           reduce using rule 120 (expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 183 ]
  ! MINUS           [ shift and go to state 186 ]
  ! MULTI           [ shift and go to state 176 ]
  ! DIVIDE          [ shift and go to state 177 ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 171

    (121) expr -> PLUS expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    PLUS            reduce using rule 121 (expr -> PLUS expr .)
    MINUS           reduce using rule 121 (expr -> PLUS expr .)
    MULTI           reduce using rule 121 (expr -> PLUS expr .)
    DIVIDE          reduce using rule 121 (expr -> PLUS expr .)
    AND             reduce using rule 121 (expr -> PLUS expr .)
    OR              reduce using rule 121 (expr -> PLUS expr .)
    EQUAL           reduce using rule 121 (expr -> PLUS expr .)
    NOTEQUAL        reduce using rule 121 (expr -> PLUS expr .)
    LESS            reduce using rule 121 (expr -> PLUS expr .)
    GREATER         reduce using rule 121 (expr -> PLUS expr .)
    LESSEQUAL       reduce using rule 121 (expr -> PLUS expr .)
    GREATEREQUAL    reduce using rule 121 (expr -> PLUS expr .)
    SEMICOLON       reduce using rule 121 (expr -> PLUS expr .)
    error           reduce using rule 121 (expr -> PLUS expr .)
    RPAREN          reduce using rule 121 (expr -> PLUS expr .)
    RSQ             reduce using rule 121 (expr -> PLUS expr .)
    COMMA           reduce using rule 121 (expr -> PLUS expr .)

  ! PLUS            [ shift and go to state 183 ]
  ! MINUS           [ shift and go to state 186 ]
  ! MULTI           [ shift and go to state 176 ]
  ! DIVIDE          [ shift and go to state 177 ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 172

    (125) newarrayw -> newarrayw LSQ . RSQ

    RSQ             shift and go to state 207


state 173

    (128) newarrayp -> newarrayp LSQ . expr RSQ
    (126) newarrayw -> newarrayp LSQ . RSQ
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    RSQ             shift and go to state 209
    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    field_access                   shift and go to state 123
    pnew                           shift and go to state 73
    expr                           shift and go to state 208
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    newarrayp                      shift and go to state 125
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 174

    (109) expr -> expr AND . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 210
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 175

    (112) expr -> expr NOTEQUAL . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 211
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 176

    (107) expr -> expr MULTI . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 212
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 177

    (108) expr -> expr DIVIDE . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 213
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 178

    (68) other_stmt -> RETURN expr SEMICOLON .

    ELSE            reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    RBIG            reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    BREAK           reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    CONTINUE        reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    error           reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    INCREMENT       reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    DECREMENT       reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    LBIG            reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    INT             reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    BOOLEAN         reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    ID              reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    THIS            reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    SUPER           reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    LPAREN          reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    INT_CONST       reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    STRING_CONST    reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    NULL            reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    TRUE            reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    FALSE           reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)
    NEW             reduce using rule 68 (other_stmt -> RETURN expr SEMICOLON .)


state 179

    (113) expr -> expr LESS . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 214
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 180

    (116) expr -> expr GREATEREQUAL . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 215
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 181

    (111) expr -> expr EQUAL . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 216
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 182

    (110) expr -> expr OR . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 217
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 183

    (105) expr -> expr PLUS . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 218
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 184

    (70) other_stmt -> RETURN expr error .

    ELSE            reduce using rule 70 (other_stmt -> RETURN expr error .)
    RBIG            reduce using rule 70 (other_stmt -> RETURN expr error .)
    IF              reduce using rule 70 (other_stmt -> RETURN expr error .)
    WHILE           reduce using rule 70 (other_stmt -> RETURN expr error .)
    RETURN          reduce using rule 70 (other_stmt -> RETURN expr error .)
    BREAK           reduce using rule 70 (other_stmt -> RETURN expr error .)
    CONTINUE        reduce using rule 70 (other_stmt -> RETURN expr error .)
    SEMICOLON       reduce using rule 70 (other_stmt -> RETURN expr error .)
    error           reduce using rule 70 (other_stmt -> RETURN expr error .)
    INCREMENT       reduce using rule 70 (other_stmt -> RETURN expr error .)
    DECREMENT       reduce using rule 70 (other_stmt -> RETURN expr error .)
    LBIG            reduce using rule 70 (other_stmt -> RETURN expr error .)
    INT             reduce using rule 70 (other_stmt -> RETURN expr error .)
    FLOAT           reduce using rule 70 (other_stmt -> RETURN expr error .)
    BOOLEAN         reduce using rule 70 (other_stmt -> RETURN expr error .)
    ID              reduce using rule 70 (other_stmt -> RETURN expr error .)
    FOR             reduce using rule 70 (other_stmt -> RETURN expr error .)
    THIS            reduce using rule 70 (other_stmt -> RETURN expr error .)
    SUPER           reduce using rule 70 (other_stmt -> RETURN expr error .)
    LPAREN          reduce using rule 70 (other_stmt -> RETURN expr error .)
    INT_CONST       reduce using rule 70 (other_stmt -> RETURN expr error .)
    FLOAT_CONST     reduce using rule 70 (other_stmt -> RETURN expr error .)
    STRING_CONST    reduce using rule 70 (other_stmt -> RETURN expr error .)
    NULL            reduce using rule 70 (other_stmt -> RETURN expr error .)
    TRUE            reduce using rule 70 (other_stmt -> RETURN expr error .)
    FALSE           reduce using rule 70 (other_stmt -> RETURN expr error .)
    NEW             reduce using rule 70 (other_stmt -> RETURN expr error .)


state 185

    (115) expr -> expr LESSEQUAL . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 219
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 186

    (106) expr -> expr MINUS . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 220
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 187

    (114) expr -> expr GREATER . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 221
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 188

    (122) expr -> NOT expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    PLUS            reduce using rule 122 (expr -> NOT expr .)
    MINUS           reduce using rule 122 (expr -> NOT expr .)
    MULTI           reduce using rule 122 (expr -> NOT expr .)
    DIVIDE          reduce using rule 122 (expr -> NOT expr .)
    AND             reduce using rule 122 (expr -> NOT expr .)
    OR              reduce using rule 122 (expr -> NOT expr .)
    EQUAL           reduce using rule 122 (expr -> NOT expr .)
    NOTEQUAL        reduce using rule 122 (expr -> NOT expr .)
    LESS            reduce using rule 122 (expr -> NOT expr .)
    GREATER         reduce using rule 122 (expr -> NOT expr .)
    LESSEQUAL       reduce using rule 122 (expr -> NOT expr .)
    GREATEREQUAL    reduce using rule 122 (expr -> NOT expr .)
    SEMICOLON       reduce using rule 122 (expr -> NOT expr .)
    error           reduce using rule 122 (expr -> NOT expr .)
    RPAREN          reduce using rule 122 (expr -> NOT expr .)
    RSQ             reduce using rule 122 (expr -> NOT expr .)
    COMMA           reduce using rule 122 (expr -> NOT expr .)

  ! PLUS            [ shift and go to state 183 ]
  ! MINUS           [ shift and go to state 186 ]
  ! MULTI           [ shift and go to state 176 ]
  ! DIVIDE          [ shift and go to state 177 ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 189

    (100) field_access -> primary POINT ID .

    LPAREN          reduce using rule 100 (field_access -> primary POINT ID .)
    ASSIGN          reduce using rule 100 (field_access -> primary POINT ID .)
    INCREMENT       reduce using rule 100 (field_access -> primary POINT ID .)
    DECREMENT       reduce using rule 100 (field_access -> primary POINT ID .)
    POINT           reduce using rule 100 (field_access -> primary POINT ID .)
    LSQ             reduce using rule 100 (field_access -> primary POINT ID .)
    PLUS            reduce using rule 100 (field_access -> primary POINT ID .)
    MINUS           reduce using rule 100 (field_access -> primary POINT ID .)
    MULTI           reduce using rule 100 (field_access -> primary POINT ID .)
    DIVIDE          reduce using rule 100 (field_access -> primary POINT ID .)
    AND             reduce using rule 100 (field_access -> primary POINT ID .)
    OR              reduce using rule 100 (field_access -> primary POINT ID .)
    EQUAL           reduce using rule 100 (field_access -> primary POINT ID .)
    NOTEQUAL        reduce using rule 100 (field_access -> primary POINT ID .)
    LESS            reduce using rule 100 (field_access -> primary POINT ID .)
    GREATER         reduce using rule 100 (field_access -> primary POINT ID .)
    LESSEQUAL       reduce using rule 100 (field_access -> primary POINT ID .)
    GREATEREQUAL    reduce using rule 100 (field_access -> primary POINT ID .)
    RPAREN          reduce using rule 100 (field_access -> primary POINT ID .)
    COMMA           reduce using rule 100 (field_access -> primary POINT ID .)
    SEMICOLON       reduce using rule 100 (field_access -> primary POINT ID .)
    error           reduce using rule 100 (field_access -> primary POINT ID .)
    RSQ             reduce using rule 100 (field_access -> primary POINT ID .)


state 190

    (102) array_access -> primary LSQ expr . RSQ
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RSQ             shift and go to state 222
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 191

    (56) noncompleteif_stmt -> WHILE LPAREN expr . RPAREN noncompleteif_stmt
    (59) other_stmt -> WHILE LPAREN expr . RPAREN other_stmt
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RPAREN          shift and go to state 223
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 192

    (103) method_invocation -> field_access LPAREN RPAREN .

    POINT           reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    LSQ             reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    RSQ             reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    PLUS            reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    MINUS           reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    MULTI           reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    DIVIDE          reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    AND             reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    OR              reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    EQUAL           reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    LESS            reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    GREATER         reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    LESSEQUAL       reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    GREATEREQUAL    reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    SEMICOLON       reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    error           reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    RPAREN          reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)
    COMMA           reduce using rule 103 (method_invocation -> field_access LPAREN RPAREN .)


state 193

    (104) method_invocation -> field_access LPAREN arguments . RPAREN
    (97) arguments -> arguments . COMMA expr

    RPAREN          shift and go to state 224
    COMMA           shift and go to state 225


state 194

    (96) arguments -> expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RPAREN          reduce using rule 96 (arguments -> expr .)
    COMMA           reduce using rule 96 (arguments -> expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 195

    (60) forbasic1 -> FOR LPAREN SEMICOLON .

    SEMICOLON       reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    MINUS           reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    PLUS            reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    NOT             reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    THIS            reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    SUPER           reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    LPAREN          reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    INCREMENT       reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    DECREMENT       reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    INT_CONST       reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    FLOAT_CONST     reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    STRING_CONST    reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    NULL            reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    TRUE            reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    FALSE           reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    NEW             reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)
    ID              reduce using rule 60 (forbasic1 -> FOR LPAREN SEMICOLON .)


state 196

    (61) forbasic1 -> FOR LPAREN stmt_expr . SEMICOLON

    SEMICOLON       shift and go to state 226


state 197

    (91) pnew -> pnew1 LPAREN RPAREN .

    POINT           reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    LSQ             reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    RPAREN          reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    PLUS            reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    MINUS           reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    MULTI           reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    DIVIDE          reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    AND             reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    OR              reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    EQUAL           reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    LESS            reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    GREATER         reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    LESSEQUAL       reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    GREATEREQUAL    reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    COMMA           reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    SEMICOLON       reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    error           reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)
    RSQ             reduce using rule 91 (pnew -> pnew1 LPAREN RPAREN .)


state 198

    (92) pnew -> pnew1 LPAREN arguments . RPAREN
    (97) arguments -> arguments . COMMA expr

    RPAREN          shift and go to state 227
    COMMA           shift and go to state 225


state 199

    (65) forbasic -> forbasic2 stmt_expr RPAREN .

    IF              reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    WHILE           reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    RETURN          reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    BREAK           reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    CONTINUE        reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    SEMICOLON       reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    error           reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    INCREMENT       reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    DECREMENT       reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    LBIG            reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    INT             reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    FLOAT           reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    BOOLEAN         reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    ID              reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    FOR             reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    THIS            reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    SUPER           reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    LPAREN          reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    INT_CONST       reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    FLOAT_CONST     reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    STRING_CONST    reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    NULL            reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    TRUE            reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    FALSE           reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)
    NEW             reduce using rule 65 (forbasic -> forbasic2 stmt_expr RPAREN .)


state 200

    (89) primary -> LPAREN expr RPAREN .

    POINT           reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    LSQ             reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    MULTI           reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    AND             reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    OR              reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    NOTEQUAL        reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    LESS            reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    LESSEQUAL       reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    GREATEREQUAL    reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    error           reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    RSQ             reduce using rule 89 (primary -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 89 (primary -> LPAREN expr RPAREN .)


state 201

    (63) forbasic2 -> forbasic1 expr SEMICOLON .

    RPAREN          reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    error           reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    INCREMENT       reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    DECREMENT       reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    ID              reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    THIS            reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    SUPER           reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    LPAREN          reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    INT_CONST       reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    STRING_CONST    reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    NULL            reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    TRUE            reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    FALSE           reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)
    NEW             reduce using rule 63 (forbasic2 -> forbasic1 expr SEMICOLON .)


state 202

    (54) noncompleteif_stmt -> IF LPAREN expr . RPAREN stmt
    (55) noncompleteif_stmt -> IF LPAREN expr . RPAREN other_stmt ELSE noncompleteif_stmt
    (58) other_stmt -> IF LPAREN expr . RPAREN other_stmt ELSE other_stmt
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RPAREN          shift and go to state 228
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 203

    (129) assign -> lhs ASSIGN expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RPAREN          reduce using rule 129 (assign -> lhs ASSIGN expr .)
    SEMICOLON       reduce using rule 129 (assign -> lhs ASSIGN expr .)
    error           reduce using rule 129 (assign -> lhs ASSIGN expr .)
    RSQ             reduce using rule 129 (assign -> lhs ASSIGN expr .)
    COMMA           reduce using rule 129 (assign -> lhs ASSIGN expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180

  ! PLUS            [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! MINUS           [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! MULTI           [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! DIVIDE          [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! AND             [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! OR              [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! EQUAL           [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! NOTEQUAL        [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! LESS            [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! GREATER         [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! LESSEQUAL       [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]
  ! GREATEREQUAL    [ reduce using rule 129 (assign -> lhs ASSIGN expr .) ]


state 204

    (43) constructor_decl -> modifier ID LPAREN formals RPAREN block .

    RBIG            reduce using rule 43 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 43 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 43 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    ID              reduce using rule 43 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 43 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    INT             reduce using rule 43 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 43 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 43 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    error           reduce using rule 43 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 43 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)


state 205

    (45) constructor_decl -> modifier ID error formals RPAREN block .

    RBIG            reduce using rule 45 (constructor_decl -> modifier ID error formals RPAREN block .)
    PUBLIC          reduce using rule 45 (constructor_decl -> modifier ID error formals RPAREN block .)
    PRIVATE         reduce using rule 45 (constructor_decl -> modifier ID error formals RPAREN block .)
    ID              reduce using rule 45 (constructor_decl -> modifier ID error formals RPAREN block .)
    VOID            reduce using rule 45 (constructor_decl -> modifier ID error formals RPAREN block .)
    INT             reduce using rule 45 (constructor_decl -> modifier ID error formals RPAREN block .)
    FLOAT           reduce using rule 45 (constructor_decl -> modifier ID error formals RPAREN block .)
    BOOLEAN         reduce using rule 45 (constructor_decl -> modifier ID error formals RPAREN block .)
    error           reduce using rule 45 (constructor_decl -> modifier ID error formals RPAREN block .)
    STATIC          reduce using rule 45 (constructor_decl -> modifier ID error formals RPAREN block .)


state 206

    (127) newarrayp -> NEW type LSQ . expr RSQ
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 229
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    array_access                   shift and go to state 67
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    assign                         shift and go to state 133

state 207

    (125) newarrayw -> newarrayw LSQ RSQ .

    LSQ             reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    PLUS            reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    MINUS           reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    MULTI           reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    DIVIDE          reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    AND             reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    OR              reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    EQUAL           reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    NOTEQUAL        reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    LESS            reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    GREATER         reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    LESSEQUAL       reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    GREATEREQUAL    reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    SEMICOLON       reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    error           reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    RPAREN          reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    RSQ             reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)
    COMMA           reduce using rule 125 (newarrayw -> newarrayw LSQ RSQ .)


state 208

    (128) newarrayp -> newarrayp LSQ expr . RSQ
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RSQ             shift and go to state 230
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 209

    (126) newarrayw -> newarrayp LSQ RSQ .

    LSQ             reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    PLUS            reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    MINUS           reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    MULTI           reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    DIVIDE          reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    AND             reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    OR              reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    EQUAL           reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    NOTEQUAL        reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    LESS            reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    GREATER         reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    LESSEQUAL       reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    GREATEREQUAL    reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    SEMICOLON       reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    error           reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    RPAREN          reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    RSQ             reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)
    COMMA           reduce using rule 126 (newarrayw -> newarrayp LSQ RSQ .)


state 210

    (109) expr -> expr AND expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    AND             reduce using rule 109 (expr -> expr AND expr .)
    OR              reduce using rule 109 (expr -> expr AND expr .)
    SEMICOLON       reduce using rule 109 (expr -> expr AND expr .)
    error           reduce using rule 109 (expr -> expr AND expr .)
    RPAREN          reduce using rule 109 (expr -> expr AND expr .)
    RSQ             reduce using rule 109 (expr -> expr AND expr .)
    COMMA           reduce using rule 109 (expr -> expr AND expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180

  ! PLUS            [ reduce using rule 109 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 109 (expr -> expr AND expr .) ]
  ! MULTI           [ reduce using rule 109 (expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 109 (expr -> expr AND expr .) ]
  ! EQUAL           [ reduce using rule 109 (expr -> expr AND expr .) ]
  ! NOTEQUAL        [ reduce using rule 109 (expr -> expr AND expr .) ]
  ! LESS            [ reduce using rule 109 (expr -> expr AND expr .) ]
  ! GREATER         [ reduce using rule 109 (expr -> expr AND expr .) ]
  ! LESSEQUAL       [ reduce using rule 109 (expr -> expr AND expr .) ]
  ! GREATEREQUAL    [ reduce using rule 109 (expr -> expr AND expr .) ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]


state 211

    (112) expr -> expr NOTEQUAL expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    AND             reduce using rule 112 (expr -> expr NOTEQUAL expr .)
    OR              reduce using rule 112 (expr -> expr NOTEQUAL expr .)
    EQUAL           reduce using rule 112 (expr -> expr NOTEQUAL expr .)
    NOTEQUAL        reduce using rule 112 (expr -> expr NOTEQUAL expr .)
    SEMICOLON       reduce using rule 112 (expr -> expr NOTEQUAL expr .)
    error           reduce using rule 112 (expr -> expr NOTEQUAL expr .)
    RPAREN          reduce using rule 112 (expr -> expr NOTEQUAL expr .)
    RSQ             reduce using rule 112 (expr -> expr NOTEQUAL expr .)
    COMMA           reduce using rule 112 (expr -> expr NOTEQUAL expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180

  ! PLUS            [ reduce using rule 112 (expr -> expr NOTEQUAL expr .) ]
  ! MINUS           [ reduce using rule 112 (expr -> expr NOTEQUAL expr .) ]
  ! MULTI           [ reduce using rule 112 (expr -> expr NOTEQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 112 (expr -> expr NOTEQUAL expr .) ]
  ! LESS            [ reduce using rule 112 (expr -> expr NOTEQUAL expr .) ]
  ! GREATER         [ reduce using rule 112 (expr -> expr NOTEQUAL expr .) ]
  ! LESSEQUAL       [ reduce using rule 112 (expr -> expr NOTEQUAL expr .) ]
  ! GREATEREQUAL    [ reduce using rule 112 (expr -> expr NOTEQUAL expr .) ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]


state 212

    (107) expr -> expr MULTI expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    PLUS            reduce using rule 107 (expr -> expr MULTI expr .)
    MINUS           reduce using rule 107 (expr -> expr MULTI expr .)
    MULTI           reduce using rule 107 (expr -> expr MULTI expr .)
    DIVIDE          reduce using rule 107 (expr -> expr MULTI expr .)
    AND             reduce using rule 107 (expr -> expr MULTI expr .)
    OR              reduce using rule 107 (expr -> expr MULTI expr .)
    EQUAL           reduce using rule 107 (expr -> expr MULTI expr .)
    NOTEQUAL        reduce using rule 107 (expr -> expr MULTI expr .)
    LESS            reduce using rule 107 (expr -> expr MULTI expr .)
    GREATER         reduce using rule 107 (expr -> expr MULTI expr .)
    LESSEQUAL       reduce using rule 107 (expr -> expr MULTI expr .)
    GREATEREQUAL    reduce using rule 107 (expr -> expr MULTI expr .)
    SEMICOLON       reduce using rule 107 (expr -> expr MULTI expr .)
    error           reduce using rule 107 (expr -> expr MULTI expr .)
    RPAREN          reduce using rule 107 (expr -> expr MULTI expr .)
    RSQ             reduce using rule 107 (expr -> expr MULTI expr .)
    COMMA           reduce using rule 107 (expr -> expr MULTI expr .)

  ! PLUS            [ shift and go to state 183 ]
  ! MINUS           [ shift and go to state 186 ]
  ! MULTI           [ shift and go to state 176 ]
  ! DIVIDE          [ shift and go to state 177 ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 213

    (108) expr -> expr DIVIDE expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    PLUS            reduce using rule 108 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 108 (expr -> expr DIVIDE expr .)
    MULTI           reduce using rule 108 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 108 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 108 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 108 (expr -> expr DIVIDE expr .)
    EQUAL           reduce using rule 108 (expr -> expr DIVIDE expr .)
    NOTEQUAL        reduce using rule 108 (expr -> expr DIVIDE expr .)
    LESS            reduce using rule 108 (expr -> expr DIVIDE expr .)
    GREATER         reduce using rule 108 (expr -> expr DIVIDE expr .)
    LESSEQUAL       reduce using rule 108 (expr -> expr DIVIDE expr .)
    GREATEREQUAL    reduce using rule 108 (expr -> expr DIVIDE expr .)
    SEMICOLON       reduce using rule 108 (expr -> expr DIVIDE expr .)
    error           reduce using rule 108 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 108 (expr -> expr DIVIDE expr .)
    RSQ             reduce using rule 108 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 108 (expr -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 183 ]
  ! MINUS           [ shift and go to state 186 ]
  ! MULTI           [ shift and go to state 176 ]
  ! DIVIDE          [ shift and go to state 177 ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 214

    (113) expr -> expr LESS expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    AND             reduce using rule 113 (expr -> expr LESS expr .)
    OR              reduce using rule 113 (expr -> expr LESS expr .)
    EQUAL           reduce using rule 113 (expr -> expr LESS expr .)
    NOTEQUAL        reduce using rule 113 (expr -> expr LESS expr .)
    LESS            reduce using rule 113 (expr -> expr LESS expr .)
    GREATER         reduce using rule 113 (expr -> expr LESS expr .)
    LESSEQUAL       reduce using rule 113 (expr -> expr LESS expr .)
    GREATEREQUAL    reduce using rule 113 (expr -> expr LESS expr .)
    SEMICOLON       reduce using rule 113 (expr -> expr LESS expr .)
    error           reduce using rule 113 (expr -> expr LESS expr .)
    RPAREN          reduce using rule 113 (expr -> expr LESS expr .)
    RSQ             reduce using rule 113 (expr -> expr LESS expr .)
    COMMA           reduce using rule 113 (expr -> expr LESS expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177

  ! PLUS            [ reduce using rule 113 (expr -> expr LESS expr .) ]
  ! MINUS           [ reduce using rule 113 (expr -> expr LESS expr .) ]
  ! MULTI           [ reduce using rule 113 (expr -> expr LESS expr .) ]
  ! DIVIDE          [ reduce using rule 113 (expr -> expr LESS expr .) ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 215

    (116) expr -> expr GREATEREQUAL expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    AND             reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    OR              reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    EQUAL           reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    NOTEQUAL        reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    LESS            reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    GREATER         reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    LESSEQUAL       reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    GREATEREQUAL    reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    SEMICOLON       reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    error           reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    RPAREN          reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    RSQ             reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    COMMA           reduce using rule 116 (expr -> expr GREATEREQUAL expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177

  ! PLUS            [ reduce using rule 116 (expr -> expr GREATEREQUAL expr .) ]
  ! MINUS           [ reduce using rule 116 (expr -> expr GREATEREQUAL expr .) ]
  ! MULTI           [ reduce using rule 116 (expr -> expr GREATEREQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 116 (expr -> expr GREATEREQUAL expr .) ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 216

    (111) expr -> expr EQUAL expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    AND             reduce using rule 111 (expr -> expr EQUAL expr .)
    OR              reduce using rule 111 (expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 111 (expr -> expr EQUAL expr .)
    NOTEQUAL        reduce using rule 111 (expr -> expr EQUAL expr .)
    SEMICOLON       reduce using rule 111 (expr -> expr EQUAL expr .)
    error           reduce using rule 111 (expr -> expr EQUAL expr .)
    RPAREN          reduce using rule 111 (expr -> expr EQUAL expr .)
    RSQ             reduce using rule 111 (expr -> expr EQUAL expr .)
    COMMA           reduce using rule 111 (expr -> expr EQUAL expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180

  ! PLUS            [ reduce using rule 111 (expr -> expr EQUAL expr .) ]
  ! MINUS           [ reduce using rule 111 (expr -> expr EQUAL expr .) ]
  ! MULTI           [ reduce using rule 111 (expr -> expr EQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 111 (expr -> expr EQUAL expr .) ]
  ! LESS            [ reduce using rule 111 (expr -> expr EQUAL expr .) ]
  ! GREATER         [ reduce using rule 111 (expr -> expr EQUAL expr .) ]
  ! LESSEQUAL       [ reduce using rule 111 (expr -> expr EQUAL expr .) ]
  ! GREATEREQUAL    [ reduce using rule 111 (expr -> expr EQUAL expr .) ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]


state 217

    (110) expr -> expr OR expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    OR              reduce using rule 110 (expr -> expr OR expr .)
    SEMICOLON       reduce using rule 110 (expr -> expr OR expr .)
    error           reduce using rule 110 (expr -> expr OR expr .)
    RPAREN          reduce using rule 110 (expr -> expr OR expr .)
    RSQ             reduce using rule 110 (expr -> expr OR expr .)
    COMMA           reduce using rule 110 (expr -> expr OR expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180

  ! PLUS            [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! MULTI           [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! EQUAL           [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! NOTEQUAL        [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! LESS            [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! GREATER         [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! LESSEQUAL       [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! GREATEREQUAL    [ reduce using rule 110 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 182 ]


state 218

    (105) expr -> expr PLUS expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    PLUS            reduce using rule 105 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 105 (expr -> expr PLUS expr .)
    AND             reduce using rule 105 (expr -> expr PLUS expr .)
    OR              reduce using rule 105 (expr -> expr PLUS expr .)
    EQUAL           reduce using rule 105 (expr -> expr PLUS expr .)
    NOTEQUAL        reduce using rule 105 (expr -> expr PLUS expr .)
    LESS            reduce using rule 105 (expr -> expr PLUS expr .)
    GREATER         reduce using rule 105 (expr -> expr PLUS expr .)
    LESSEQUAL       reduce using rule 105 (expr -> expr PLUS expr .)
    GREATEREQUAL    reduce using rule 105 (expr -> expr PLUS expr .)
    SEMICOLON       reduce using rule 105 (expr -> expr PLUS expr .)
    error           reduce using rule 105 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 105 (expr -> expr PLUS expr .)
    RSQ             reduce using rule 105 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 105 (expr -> expr PLUS expr .)
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177

  ! MULTI           [ reduce using rule 105 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 105 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 183 ]
  ! MINUS           [ shift and go to state 186 ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 219

    (115) expr -> expr LESSEQUAL expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    AND             reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    OR              reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    EQUAL           reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    NOTEQUAL        reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    LESS            reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    GREATER         reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    LESSEQUAL       reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    GREATEREQUAL    reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    SEMICOLON       reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    error           reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    RPAREN          reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    RSQ             reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    COMMA           reduce using rule 115 (expr -> expr LESSEQUAL expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177

  ! PLUS            [ reduce using rule 115 (expr -> expr LESSEQUAL expr .) ]
  ! MINUS           [ reduce using rule 115 (expr -> expr LESSEQUAL expr .) ]
  ! MULTI           [ reduce using rule 115 (expr -> expr LESSEQUAL expr .) ]
  ! DIVIDE          [ reduce using rule 115 (expr -> expr LESSEQUAL expr .) ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 220

    (106) expr -> expr MINUS expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    PLUS            reduce using rule 106 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 106 (expr -> expr MINUS expr .)
    AND             reduce using rule 106 (expr -> expr MINUS expr .)
    OR              reduce using rule 106 (expr -> expr MINUS expr .)
    EQUAL           reduce using rule 106 (expr -> expr MINUS expr .)
    NOTEQUAL        reduce using rule 106 (expr -> expr MINUS expr .)
    LESS            reduce using rule 106 (expr -> expr MINUS expr .)
    GREATER         reduce using rule 106 (expr -> expr MINUS expr .)
    LESSEQUAL       reduce using rule 106 (expr -> expr MINUS expr .)
    GREATEREQUAL    reduce using rule 106 (expr -> expr MINUS expr .)
    SEMICOLON       reduce using rule 106 (expr -> expr MINUS expr .)
    error           reduce using rule 106 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 106 (expr -> expr MINUS expr .)
    RSQ             reduce using rule 106 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 106 (expr -> expr MINUS expr .)
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177

  ! MULTI           [ reduce using rule 106 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 106 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 183 ]
  ! MINUS           [ shift and go to state 186 ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 221

    (114) expr -> expr GREATER expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    AND             reduce using rule 114 (expr -> expr GREATER expr .)
    OR              reduce using rule 114 (expr -> expr GREATER expr .)
    EQUAL           reduce using rule 114 (expr -> expr GREATER expr .)
    NOTEQUAL        reduce using rule 114 (expr -> expr GREATER expr .)
    LESS            reduce using rule 114 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 114 (expr -> expr GREATER expr .)
    LESSEQUAL       reduce using rule 114 (expr -> expr GREATER expr .)
    GREATEREQUAL    reduce using rule 114 (expr -> expr GREATER expr .)
    SEMICOLON       reduce using rule 114 (expr -> expr GREATER expr .)
    error           reduce using rule 114 (expr -> expr GREATER expr .)
    RPAREN          reduce using rule 114 (expr -> expr GREATER expr .)
    RSQ             reduce using rule 114 (expr -> expr GREATER expr .)
    COMMA           reduce using rule 114 (expr -> expr GREATER expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177

  ! PLUS            [ reduce using rule 114 (expr -> expr GREATER expr .) ]
  ! MINUS           [ reduce using rule 114 (expr -> expr GREATER expr .) ]
  ! MULTI           [ reduce using rule 114 (expr -> expr GREATER expr .) ]
  ! DIVIDE          [ reduce using rule 114 (expr -> expr GREATER expr .) ]
  ! AND             [ shift and go to state 174 ]
  ! OR              [ shift and go to state 182 ]
  ! EQUAL           [ shift and go to state 181 ]
  ! NOTEQUAL        [ shift and go to state 175 ]
  ! LESS            [ shift and go to state 179 ]
  ! GREATER         [ shift and go to state 187 ]
  ! LESSEQUAL       [ shift and go to state 185 ]
  ! GREATEREQUAL    [ shift and go to state 180 ]


state 222

    (102) array_access -> primary LSQ expr RSQ .

    ASSIGN          reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    INCREMENT       reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    DECREMENT       reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    POINT           reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    LSQ             reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    PLUS            reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    MINUS           reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    MULTI           reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    DIVIDE          reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    AND             reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    OR              reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    EQUAL           reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    NOTEQUAL        reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    LESS            reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    GREATER         reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    LESSEQUAL       reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    GREATEREQUAL    reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    SEMICOLON       reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    error           reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    RPAREN          reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    RSQ             reduce using rule 102 (array_access -> primary LSQ expr RSQ .)
    COMMA           reduce using rule 102 (array_access -> primary LSQ expr RSQ .)


state 223

    (56) noncompleteif_stmt -> WHILE LPAREN expr RPAREN . noncompleteif_stmt
    (59) other_stmt -> WHILE LPAREN expr RPAREN . other_stmt
    (54) noncompleteif_stmt -> . IF LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
    (56) noncompleteif_stmt -> . WHILE LPAREN expr RPAREN noncompleteif_stmt
    (57) noncompleteif_stmt -> . forbasic noncompleteif_stmt
    (58) other_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE other_stmt
    (59) other_stmt -> . WHILE LPAREN expr RPAREN other_stmt
    (66) other_stmt -> . forbasic other_stmt
    (67) other_stmt -> . RETURN SEMICOLON
    (68) other_stmt -> . RETURN expr SEMICOLON
    (69) other_stmt -> . RETURN error
    (70) other_stmt -> . RETURN expr error
    (71) other_stmt -> . stmt_expr SEMICOLON
    (72) other_stmt -> . stmt_expr error
    (73) other_stmt -> . BREAK SEMICOLON
    (74) other_stmt -> . BREAK error
    (75) other_stmt -> . CONTINUE SEMICOLON
    (76) other_stmt -> . CONTINUE error
    (77) other_stmt -> . block
    (78) other_stmt -> . var_decl
    (79) other_stmt -> . SEMICOLON
    (64) forbasic -> . forbasic2 RPAREN
    (65) forbasic -> . forbasic2 stmt_expr RPAREN
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (51) block -> . block1 RBIG
    (26) var_decl -> . type variables SEMICOLON
    (27) var_decl -> . type variables error
    (62) forbasic2 -> . forbasic1 SEMICOLON
    (63) forbasic2 -> . forbasic1 expr SEMICOLON
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error
    (60) forbasic1 -> . FOR LPAREN SEMICOLON
    (61) forbasic1 -> . FOR LPAREN stmt_expr SEMICOLON
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    IF              shift and go to state 89
    WHILE           shift and go to state 63
    RETURN          shift and go to state 61
    BREAK           shift and go to state 93
    CONTINUE        shift and go to state 95
    SEMICOLON       shift and go to state 70
    error           shift and go to state 97
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    LBIG            shift and go to state 46
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 88
    FOR             shift and go to state 80
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    block1                         shift and go to state 45
    primary                        shift and go to state 62
    array_access                   shift and go to state 67
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 74
    literal                        shift and go to state 72
    forbasic                       shift and go to state 75
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    forbasic2                      shift and go to state 82
    forbasic1                      shift and go to state 87
    noncompleteif_stmt             shift and go to state 231
    var_decl                       shift and go to state 92
    other_stmt                     shift and go to state 232
    lhs                            shift and go to state 96
    assign                         shift and go to state 100
    block                          shift and go to state 101

state 224

    (104) method_invocation -> field_access LPAREN arguments RPAREN .

    POINT           reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LSQ             reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RSQ             reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PLUS            reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MINUS           reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MULTI           reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    AND             reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    OR              reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESS            reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATER         reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESSEQUAL       reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATEREQUAL    reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    error           reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)
    COMMA           reduce using rule 104 (method_invocation -> field_access LPAREN arguments RPAREN .)


state 225

    (97) arguments -> arguments COMMA . expr
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    newarrayp                      shift and go to state 125
    field_access                   shift and go to state 123
    expr                           shift and go to state 233
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarrayw                      shift and go to state 124
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133
    newarray                       shift and go to state 130

state 226

    (61) forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .

    SEMICOLON       reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    MINUS           reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    PLUS            reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    NOT             reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    THIS            reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    SUPER           reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    LPAREN          reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    INCREMENT       reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    DECREMENT       reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    INT_CONST       reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    FLOAT_CONST     reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    STRING_CONST    reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    NULL            reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    TRUE            reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    FALSE           reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    NEW             reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)
    ID              reduce using rule 61 (forbasic1 -> FOR LPAREN stmt_expr SEMICOLON .)


state 227

    (92) pnew -> pnew1 LPAREN arguments RPAREN .

    POINT           reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    LSQ             reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    PLUS            reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    MINUS           reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    MULTI           reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    AND             reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    OR              reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    LESS            reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    GREATER         reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    LESSEQUAL       reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    GREATEREQUAL    reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    COMMA           reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    error           reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)
    RSQ             reduce using rule 92 (pnew -> pnew1 LPAREN arguments RPAREN .)


state 228

    (54) noncompleteif_stmt -> IF LPAREN expr RPAREN . stmt
    (55) noncompleteif_stmt -> IF LPAREN expr RPAREN . other_stmt ELSE noncompleteif_stmt
    (58) other_stmt -> IF LPAREN expr RPAREN . other_stmt ELSE other_stmt
    (52) stmt -> . noncompleteif_stmt
    (53) stmt -> . other_stmt
    (58) other_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE other_stmt
    (59) other_stmt -> . WHILE LPAREN expr RPAREN other_stmt
    (66) other_stmt -> . forbasic other_stmt
    (67) other_stmt -> . RETURN SEMICOLON
    (68) other_stmt -> . RETURN expr SEMICOLON
    (69) other_stmt -> . RETURN error
    (70) other_stmt -> . RETURN expr error
    (71) other_stmt -> . stmt_expr SEMICOLON
    (72) other_stmt -> . stmt_expr error
    (73) other_stmt -> . BREAK SEMICOLON
    (74) other_stmt -> . BREAK error
    (75) other_stmt -> . CONTINUE SEMICOLON
    (76) other_stmt -> . CONTINUE error
    (77) other_stmt -> . block
    (78) other_stmt -> . var_decl
    (79) other_stmt -> . SEMICOLON
    (54) noncompleteif_stmt -> . IF LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
    (56) noncompleteif_stmt -> . WHILE LPAREN expr RPAREN noncompleteif_stmt
    (57) noncompleteif_stmt -> . forbasic noncompleteif_stmt
    (64) forbasic -> . forbasic2 RPAREN
    (65) forbasic -> . forbasic2 stmt_expr RPAREN
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (51) block -> . block1 RBIG
    (26) var_decl -> . type variables SEMICOLON
    (27) var_decl -> . type variables error
    (62) forbasic2 -> . forbasic1 SEMICOLON
    (63) forbasic2 -> . forbasic1 expr SEMICOLON
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error
    (60) forbasic1 -> . FOR LPAREN SEMICOLON
    (61) forbasic1 -> . FOR LPAREN stmt_expr SEMICOLON
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    IF              shift and go to state 237
    WHILE           shift and go to state 234
    RETURN          shift and go to state 61
    BREAK           shift and go to state 93
    CONTINUE        shift and go to state 95
    SEMICOLON       shift and go to state 70
    error           shift and go to state 97
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    LBIG            shift and go to state 46
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 88
    FOR             shift and go to state 80
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    block1                         shift and go to state 45
    primary                        shift and go to state 62
    array_access                   shift and go to state 67
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 74
    literal                        shift and go to state 72
    forbasic                       shift and go to state 235
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    forbasic2                      shift and go to state 82
    stmt                           shift and go to state 236
    forbasic1                      shift and go to state 87
    noncompleteif_stmt             shift and go to state 90
    var_decl                       shift and go to state 92
    other_stmt                     shift and go to state 238
    lhs                            shift and go to state 96
    assign                         shift and go to state 100
    block                          shift and go to state 101

state 229

    (127) newarrayp -> NEW type LSQ expr . RSQ
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RSQ             shift and go to state 239
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 230

    (128) newarrayp -> newarrayp LSQ expr RSQ .

    LSQ             reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    PLUS            reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    MINUS           reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    MULTI           reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    DIVIDE          reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    AND             reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    OR              reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    EQUAL           reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    NOTEQUAL        reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    LESS            reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    GREATER         reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    LESSEQUAL       reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    GREATEREQUAL    reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    SEMICOLON       reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    error           reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    RPAREN          reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    RSQ             reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)
    COMMA           reduce using rule 128 (newarrayp -> newarrayp LSQ expr RSQ .)


state 231

    (56) noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .

    RBIG            reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    IF              reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    WHILE           reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    RETURN          reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    BREAK           reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    CONTINUE        reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    SEMICOLON       reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    error           reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    INCREMENT       reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    DECREMENT       reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    LBIG            reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    INT             reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    FLOAT           reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    BOOLEAN         reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    ID              reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    FOR             reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    THIS            reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    SUPER           reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    LPAREN          reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    INT_CONST       reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    FLOAT_CONST     reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    STRING_CONST    reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    NULL            reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    TRUE            reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    FALSE           reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)
    NEW             reduce using rule 56 (noncompleteif_stmt -> WHILE LPAREN expr RPAREN noncompleteif_stmt .)


state 232

    (59) other_stmt -> WHILE LPAREN expr RPAREN other_stmt .

    ELSE            reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    RBIG            reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    IF              reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    WHILE           reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    RETURN          reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    BREAK           reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    CONTINUE        reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    SEMICOLON       reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    error           reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    INCREMENT       reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    DECREMENT       reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    LBIG            reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    INT             reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    FLOAT           reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    BOOLEAN         reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    ID              reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    FOR             reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    THIS            reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    SUPER           reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    LPAREN          reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    INT_CONST       reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    FLOAT_CONST     reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    STRING_CONST    reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    NULL            reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    TRUE            reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    FALSE           reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)
    NEW             reduce using rule 59 (other_stmt -> WHILE LPAREN expr RPAREN other_stmt .)


state 233

    (97) arguments -> arguments COMMA expr .
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RPAREN          reduce using rule 97 (arguments -> arguments COMMA expr .)
    COMMA           reduce using rule 97 (arguments -> arguments COMMA expr .)
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 234

    (59) other_stmt -> WHILE . LPAREN expr RPAREN other_stmt
    (56) noncompleteif_stmt -> WHILE . LPAREN expr RPAREN noncompleteif_stmt

    LPAREN          shift and go to state 240


state 235

    (66) other_stmt -> forbasic . other_stmt
    (57) noncompleteif_stmt -> forbasic . noncompleteif_stmt
    (58) other_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE other_stmt
    (59) other_stmt -> . WHILE LPAREN expr RPAREN other_stmt
    (66) other_stmt -> . forbasic other_stmt
    (67) other_stmt -> . RETURN SEMICOLON
    (68) other_stmt -> . RETURN expr SEMICOLON
    (69) other_stmt -> . RETURN error
    (70) other_stmt -> . RETURN expr error
    (71) other_stmt -> . stmt_expr SEMICOLON
    (72) other_stmt -> . stmt_expr error
    (73) other_stmt -> . BREAK SEMICOLON
    (74) other_stmt -> . BREAK error
    (75) other_stmt -> . CONTINUE SEMICOLON
    (76) other_stmt -> . CONTINUE error
    (77) other_stmt -> . block
    (78) other_stmt -> . var_decl
    (79) other_stmt -> . SEMICOLON
    (54) noncompleteif_stmt -> . IF LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
    (56) noncompleteif_stmt -> . WHILE LPAREN expr RPAREN noncompleteif_stmt
    (57) noncompleteif_stmt -> . forbasic noncompleteif_stmt
    (64) forbasic -> . forbasic2 RPAREN
    (65) forbasic -> . forbasic2 stmt_expr RPAREN
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (51) block -> . block1 RBIG
    (26) var_decl -> . type variables SEMICOLON
    (27) var_decl -> . type variables error
    (62) forbasic2 -> . forbasic1 SEMICOLON
    (63) forbasic2 -> . forbasic1 expr SEMICOLON
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error
    (60) forbasic1 -> . FOR LPAREN SEMICOLON
    (61) forbasic1 -> . FOR LPAREN stmt_expr SEMICOLON
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    IF              shift and go to state 237
    WHILE           shift and go to state 234
    RETURN          shift and go to state 61
    BREAK           shift and go to state 93
    CONTINUE        shift and go to state 95
    SEMICOLON       shift and go to state 70
    error           shift and go to state 97
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    LBIG            shift and go to state 46
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 88
    FOR             shift and go to state 80
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    block1                         shift and go to state 45
    primary                        shift and go to state 62
    array_access                   shift and go to state 67
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 74
    literal                        shift and go to state 72
    forbasic                       shift and go to state 235
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    forbasic2                      shift and go to state 82
    forbasic1                      shift and go to state 87
    noncompleteif_stmt             shift and go to state 140
    var_decl                       shift and go to state 92
    other_stmt                     shift and go to state 141
    lhs                            shift and go to state 96
    assign                         shift and go to state 100
    block                          shift and go to state 101

state 236

    (54) noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .

    RBIG            reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    IF              reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    BREAK           reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    CONTINUE        reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    error           reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    INCREMENT       reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    DECREMENT       reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    LBIG            reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    INT             reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT           reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    BOOLEAN         reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    ID              reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    THIS            reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    SUPER           reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    INT_CONST       reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    FLOAT_CONST     reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    STRING_CONST    reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    TRUE            reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    FALSE           reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)
    NEW             reduce using rule 54 (noncompleteif_stmt -> IF LPAREN expr RPAREN stmt .)


state 237

    (58) other_stmt -> IF . LPAREN expr RPAREN other_stmt ELSE other_stmt
    (54) noncompleteif_stmt -> IF . LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> IF . LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt

    LPAREN          shift and go to state 241


state 238

    (55) noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt . ELSE noncompleteif_stmt
    (58) other_stmt -> IF LPAREN expr RPAREN other_stmt . ELSE other_stmt
    (53) stmt -> other_stmt .

    ELSE            shift and go to state 242
    RBIG            reduce using rule 53 (stmt -> other_stmt .)
    IF              reduce using rule 53 (stmt -> other_stmt .)
    WHILE           reduce using rule 53 (stmt -> other_stmt .)
    RETURN          reduce using rule 53 (stmt -> other_stmt .)
    BREAK           reduce using rule 53 (stmt -> other_stmt .)
    CONTINUE        reduce using rule 53 (stmt -> other_stmt .)
    SEMICOLON       reduce using rule 53 (stmt -> other_stmt .)
    error           reduce using rule 53 (stmt -> other_stmt .)
    INCREMENT       reduce using rule 53 (stmt -> other_stmt .)
    DECREMENT       reduce using rule 53 (stmt -> other_stmt .)
    LBIG            reduce using rule 53 (stmt -> other_stmt .)
    INT             reduce using rule 53 (stmt -> other_stmt .)
    FLOAT           reduce using rule 53 (stmt -> other_stmt .)
    BOOLEAN         reduce using rule 53 (stmt -> other_stmt .)
    ID              reduce using rule 53 (stmt -> other_stmt .)
    FOR             reduce using rule 53 (stmt -> other_stmt .)
    THIS            reduce using rule 53 (stmt -> other_stmt .)
    SUPER           reduce using rule 53 (stmt -> other_stmt .)
    LPAREN          reduce using rule 53 (stmt -> other_stmt .)
    INT_CONST       reduce using rule 53 (stmt -> other_stmt .)
    FLOAT_CONST     reduce using rule 53 (stmt -> other_stmt .)
    STRING_CONST    reduce using rule 53 (stmt -> other_stmt .)
    NULL            reduce using rule 53 (stmt -> other_stmt .)
    TRUE            reduce using rule 53 (stmt -> other_stmt .)
    FALSE           reduce using rule 53 (stmt -> other_stmt .)
    NEW             reduce using rule 53 (stmt -> other_stmt .)


state 239

    (127) newarrayp -> NEW type LSQ expr RSQ .

    LSQ             reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    PLUS            reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    MINUS           reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    MULTI           reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    DIVIDE          reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    AND             reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    OR              reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    EQUAL           reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    NOTEQUAL        reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    LESS            reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    GREATER         reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    LESSEQUAL       reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    GREATEREQUAL    reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    SEMICOLON       reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    error           reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    RPAREN          reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    RSQ             reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)
    COMMA           reduce using rule 127 (newarrayp -> NEW type LSQ expr RSQ .)


state 240

    (59) other_stmt -> WHILE LPAREN . expr RPAREN other_stmt
    (56) noncompleteif_stmt -> WHILE LPAREN . expr RPAREN noncompleteif_stmt
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    field_access                   shift and go to state 123
    expr                           shift and go to state 243
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    pnew                           shift and go to state 73
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    newarrayp                      shift and go to state 125
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 241

    (58) other_stmt -> IF LPAREN . expr RPAREN other_stmt ELSE other_stmt
    (54) noncompleteif_stmt -> IF LPAREN . expr RPAREN stmt
    (55) noncompleteif_stmt -> IF LPAREN . expr RPAREN other_stmt ELSE noncompleteif_stmt
    (105) expr -> . expr PLUS expr
    (106) expr -> . expr MINUS expr
    (107) expr -> . expr MULTI expr
    (108) expr -> . expr DIVIDE expr
    (109) expr -> . expr AND expr
    (110) expr -> . expr OR expr
    (111) expr -> . expr EQUAL expr
    (112) expr -> . expr NOTEQUAL expr
    (113) expr -> . expr LESS expr
    (114) expr -> . expr GREATER expr
    (115) expr -> . expr LESSEQUAL expr
    (116) expr -> . expr GREATEREQUAL expr
    (117) expr -> . primary
    (118) expr -> . assign
    (119) expr -> . newarray
    (120) expr -> . MINUS expr
    (121) expr -> . PLUS expr
    (122) expr -> . NOT expr
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (123) newarray -> . newarrayp
    (124) newarray -> . newarrayw
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (127) newarrayp -> . NEW type LSQ expr RSQ
    (128) newarrayp -> . newarrayp LSQ expr RSQ
    (125) newarrayw -> . newarrayw LSQ RSQ
    (126) newarrayw -> . newarrayp LSQ RSQ
    (90) pnew1 -> . NEW ID
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ

    MINUS           shift and go to state 119
    PLUS            shift and go to state 121
    NOT             shift and go to state 132
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 118
    ID              shift and go to state 127

    field_access                   shift and go to state 123
    pnew                           shift and go to state 73
    expr                           shift and go to state 244
    pnew1                          shift and go to state 81
    primary                        shift and go to state 126
    literal                        shift and go to state 72
    lhs                            shift and go to state 129
    newarray                       shift and go to state 130
    newarrayw                      shift and go to state 124
    newarrayp                      shift and go to state 125
    method_invocation              shift and go to state 122
    array_access                   shift and go to state 67
    assign                         shift and go to state 133

state 242

    (55) noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE . noncompleteif_stmt
    (58) other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE . other_stmt
    (54) noncompleteif_stmt -> . IF LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
    (56) noncompleteif_stmt -> . WHILE LPAREN expr RPAREN noncompleteif_stmt
    (57) noncompleteif_stmt -> . forbasic noncompleteif_stmt
    (58) other_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE other_stmt
    (59) other_stmt -> . WHILE LPAREN expr RPAREN other_stmt
    (66) other_stmt -> . forbasic other_stmt
    (67) other_stmt -> . RETURN SEMICOLON
    (68) other_stmt -> . RETURN expr SEMICOLON
    (69) other_stmt -> . RETURN error
    (70) other_stmt -> . RETURN expr error
    (71) other_stmt -> . stmt_expr SEMICOLON
    (72) other_stmt -> . stmt_expr error
    (73) other_stmt -> . BREAK SEMICOLON
    (74) other_stmt -> . BREAK error
    (75) other_stmt -> . CONTINUE SEMICOLON
    (76) other_stmt -> . CONTINUE error
    (77) other_stmt -> . block
    (78) other_stmt -> . var_decl
    (79) other_stmt -> . SEMICOLON
    (64) forbasic -> . forbasic2 RPAREN
    (65) forbasic -> . forbasic2 stmt_expr RPAREN
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (51) block -> . block1 RBIG
    (26) var_decl -> . type variables SEMICOLON
    (27) var_decl -> . type variables error
    (62) forbasic2 -> . forbasic1 SEMICOLON
    (63) forbasic2 -> . forbasic1 expr SEMICOLON
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error
    (60) forbasic1 -> . FOR LPAREN SEMICOLON
    (61) forbasic1 -> . FOR LPAREN stmt_expr SEMICOLON
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    IF              shift and go to state 89
    WHILE           shift and go to state 63
    RETURN          shift and go to state 61
    BREAK           shift and go to state 93
    CONTINUE        shift and go to state 95
    SEMICOLON       shift and go to state 70
    error           shift and go to state 97
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    LBIG            shift and go to state 46
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 88
    FOR             shift and go to state 80
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    block1                         shift and go to state 45
    primary                        shift and go to state 62
    array_access                   shift and go to state 67
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 74
    literal                        shift and go to state 72
    forbasic                       shift and go to state 75
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    forbasic2                      shift and go to state 82
    forbasic1                      shift and go to state 87
    noncompleteif_stmt             shift and go to state 245
    var_decl                       shift and go to state 92
    other_stmt                     shift and go to state 246
    lhs                            shift and go to state 96
    assign                         shift and go to state 100
    block                          shift and go to state 101

state 243

    (59) other_stmt -> WHILE LPAREN expr . RPAREN other_stmt
    (56) noncompleteif_stmt -> WHILE LPAREN expr . RPAREN noncompleteif_stmt
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RPAREN          shift and go to state 247
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 244

    (58) other_stmt -> IF LPAREN expr . RPAREN other_stmt ELSE other_stmt
    (54) noncompleteif_stmt -> IF LPAREN expr . RPAREN stmt
    (55) noncompleteif_stmt -> IF LPAREN expr . RPAREN other_stmt ELSE noncompleteif_stmt
    (105) expr -> expr . PLUS expr
    (106) expr -> expr . MINUS expr
    (107) expr -> expr . MULTI expr
    (108) expr -> expr . DIVIDE expr
    (109) expr -> expr . AND expr
    (110) expr -> expr . OR expr
    (111) expr -> expr . EQUAL expr
    (112) expr -> expr . NOTEQUAL expr
    (113) expr -> expr . LESS expr
    (114) expr -> expr . GREATER expr
    (115) expr -> expr . LESSEQUAL expr
    (116) expr -> expr . GREATEREQUAL expr

    RPAREN          shift and go to state 248
    PLUS            shift and go to state 183
    MINUS           shift and go to state 186
    MULTI           shift and go to state 176
    DIVIDE          shift and go to state 177
    AND             shift and go to state 174
    OR              shift and go to state 182
    EQUAL           shift and go to state 181
    NOTEQUAL        shift and go to state 175
    LESS            shift and go to state 179
    GREATER         shift and go to state 187
    LESSEQUAL       shift and go to state 185
    GREATEREQUAL    shift and go to state 180


state 245

    (55) noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .

    RBIG            reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    IF              reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    WHILE           reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    RETURN          reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    BREAK           reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    CONTINUE        reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    SEMICOLON       reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    error           reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    INCREMENT       reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    DECREMENT       reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    LBIG            reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    INT             reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    FLOAT           reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    BOOLEAN         reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    ID              reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    FOR             reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    THIS            reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    SUPER           reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    LPAREN          reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    INT_CONST       reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    FLOAT_CONST     reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    STRING_CONST    reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    NULL            reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    TRUE            reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    FALSE           reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)
    NEW             reduce using rule 55 (noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt .)


state 246

    (58) other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .

    ELSE            reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    RBIG            reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    IF              reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    WHILE           reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    RETURN          reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    BREAK           reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    CONTINUE        reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    SEMICOLON       reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    error           reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    INCREMENT       reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    DECREMENT       reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    LBIG            reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    INT             reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    FLOAT           reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    BOOLEAN         reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    ID              reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    FOR             reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    THIS            reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    SUPER           reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    LPAREN          reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    INT_CONST       reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    FLOAT_CONST     reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    STRING_CONST    reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    NULL            reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    TRUE            reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    FALSE           reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)
    NEW             reduce using rule 58 (other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE other_stmt .)


state 247

    (59) other_stmt -> WHILE LPAREN expr RPAREN . other_stmt
    (56) noncompleteif_stmt -> WHILE LPAREN expr RPAREN . noncompleteif_stmt
    (58) other_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE other_stmt
    (59) other_stmt -> . WHILE LPAREN expr RPAREN other_stmt
    (66) other_stmt -> . forbasic other_stmt
    (67) other_stmt -> . RETURN SEMICOLON
    (68) other_stmt -> . RETURN expr SEMICOLON
    (69) other_stmt -> . RETURN error
    (70) other_stmt -> . RETURN expr error
    (71) other_stmt -> . stmt_expr SEMICOLON
    (72) other_stmt -> . stmt_expr error
    (73) other_stmt -> . BREAK SEMICOLON
    (74) other_stmt -> . BREAK error
    (75) other_stmt -> . CONTINUE SEMICOLON
    (76) other_stmt -> . CONTINUE error
    (77) other_stmt -> . block
    (78) other_stmt -> . var_decl
    (79) other_stmt -> . SEMICOLON
    (54) noncompleteif_stmt -> . IF LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
    (56) noncompleteif_stmt -> . WHILE LPAREN expr RPAREN noncompleteif_stmt
    (57) noncompleteif_stmt -> . forbasic noncompleteif_stmt
    (64) forbasic -> . forbasic2 RPAREN
    (65) forbasic -> . forbasic2 stmt_expr RPAREN
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (51) block -> . block1 RBIG
    (26) var_decl -> . type variables SEMICOLON
    (27) var_decl -> . type variables error
    (62) forbasic2 -> . forbasic1 SEMICOLON
    (63) forbasic2 -> . forbasic1 expr SEMICOLON
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error
    (60) forbasic1 -> . FOR LPAREN SEMICOLON
    (61) forbasic1 -> . FOR LPAREN stmt_expr SEMICOLON
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    IF              shift and go to state 237
    WHILE           shift and go to state 234
    RETURN          shift and go to state 61
    BREAK           shift and go to state 93
    CONTINUE        shift and go to state 95
    SEMICOLON       shift and go to state 70
    error           shift and go to state 97
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    LBIG            shift and go to state 46
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 88
    FOR             shift and go to state 80
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    block1                         shift and go to state 45
    primary                        shift and go to state 62
    array_access                   shift and go to state 67
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 74
    literal                        shift and go to state 72
    forbasic                       shift and go to state 235
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    forbasic2                      shift and go to state 82
    forbasic1                      shift and go to state 87
    noncompleteif_stmt             shift and go to state 231
    var_decl                       shift and go to state 92
    other_stmt                     shift and go to state 232
    lhs                            shift and go to state 96
    assign                         shift and go to state 100
    block                          shift and go to state 101

state 248

    (58) other_stmt -> IF LPAREN expr RPAREN . other_stmt ELSE other_stmt
    (54) noncompleteif_stmt -> IF LPAREN expr RPAREN . stmt
    (55) noncompleteif_stmt -> IF LPAREN expr RPAREN . other_stmt ELSE noncompleteif_stmt
    (58) other_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE other_stmt
    (59) other_stmt -> . WHILE LPAREN expr RPAREN other_stmt
    (66) other_stmt -> . forbasic other_stmt
    (67) other_stmt -> . RETURN SEMICOLON
    (68) other_stmt -> . RETURN expr SEMICOLON
    (69) other_stmt -> . RETURN error
    (70) other_stmt -> . RETURN expr error
    (71) other_stmt -> . stmt_expr SEMICOLON
    (72) other_stmt -> . stmt_expr error
    (73) other_stmt -> . BREAK SEMICOLON
    (74) other_stmt -> . BREAK error
    (75) other_stmt -> . CONTINUE SEMICOLON
    (76) other_stmt -> . CONTINUE error
    (77) other_stmt -> . block
    (78) other_stmt -> . var_decl
    (79) other_stmt -> . SEMICOLON
    (52) stmt -> . noncompleteif_stmt
    (53) stmt -> . other_stmt
    (64) forbasic -> . forbasic2 RPAREN
    (65) forbasic -> . forbasic2 stmt_expr RPAREN
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (51) block -> . block1 RBIG
    (26) var_decl -> . type variables SEMICOLON
    (27) var_decl -> . type variables error
    (54) noncompleteif_stmt -> . IF LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
    (56) noncompleteif_stmt -> . WHILE LPAREN expr RPAREN noncompleteif_stmt
    (57) noncompleteif_stmt -> . forbasic noncompleteif_stmt
    (62) forbasic2 -> . forbasic1 SEMICOLON
    (63) forbasic2 -> . forbasic1 expr SEMICOLON
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error
    (60) forbasic1 -> . FOR LPAREN SEMICOLON
    (61) forbasic1 -> . FOR LPAREN stmt_expr SEMICOLON
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    IF              shift and go to state 237
    WHILE           shift and go to state 234
    RETURN          shift and go to state 61
    BREAK           shift and go to state 93
    CONTINUE        shift and go to state 95
    SEMICOLON       shift and go to state 70
    error           shift and go to state 97
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    LBIG            shift and go to state 46
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 88
    FOR             shift and go to state 80
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    block1                         shift and go to state 45
    primary                        shift and go to state 62
    array_access                   shift and go to state 67
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 74
    literal                        shift and go to state 72
    forbasic                       shift and go to state 235
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    forbasic2                      shift and go to state 82
    stmt                           shift and go to state 236
    forbasic1                      shift and go to state 87
    noncompleteif_stmt             shift and go to state 90
    var_decl                       shift and go to state 92
    other_stmt                     shift and go to state 249
    lhs                            shift and go to state 96
    assign                         shift and go to state 100
    block                          shift and go to state 101

state 249

    (58) other_stmt -> IF LPAREN expr RPAREN other_stmt . ELSE other_stmt
    (55) noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt . ELSE noncompleteif_stmt
    (53) stmt -> other_stmt .

    ELSE            shift and go to state 250
    RBIG            reduce using rule 53 (stmt -> other_stmt .)
    IF              reduce using rule 53 (stmt -> other_stmt .)
    WHILE           reduce using rule 53 (stmt -> other_stmt .)
    RETURN          reduce using rule 53 (stmt -> other_stmt .)
    BREAK           reduce using rule 53 (stmt -> other_stmt .)
    CONTINUE        reduce using rule 53 (stmt -> other_stmt .)
    SEMICOLON       reduce using rule 53 (stmt -> other_stmt .)
    error           reduce using rule 53 (stmt -> other_stmt .)
    INCREMENT       reduce using rule 53 (stmt -> other_stmt .)
    DECREMENT       reduce using rule 53 (stmt -> other_stmt .)
    LBIG            reduce using rule 53 (stmt -> other_stmt .)
    INT             reduce using rule 53 (stmt -> other_stmt .)
    FLOAT           reduce using rule 53 (stmt -> other_stmt .)
    BOOLEAN         reduce using rule 53 (stmt -> other_stmt .)
    ID              reduce using rule 53 (stmt -> other_stmt .)
    FOR             reduce using rule 53 (stmt -> other_stmt .)
    THIS            reduce using rule 53 (stmt -> other_stmt .)
    SUPER           reduce using rule 53 (stmt -> other_stmt .)
    LPAREN          reduce using rule 53 (stmt -> other_stmt .)
    INT_CONST       reduce using rule 53 (stmt -> other_stmt .)
    FLOAT_CONST     reduce using rule 53 (stmt -> other_stmt .)
    STRING_CONST    reduce using rule 53 (stmt -> other_stmt .)
    NULL            reduce using rule 53 (stmt -> other_stmt .)
    TRUE            reduce using rule 53 (stmt -> other_stmt .)
    FALSE           reduce using rule 53 (stmt -> other_stmt .)
    NEW             reduce using rule 53 (stmt -> other_stmt .)


state 250

    (58) other_stmt -> IF LPAREN expr RPAREN other_stmt ELSE . other_stmt
    (55) noncompleteif_stmt -> IF LPAREN expr RPAREN other_stmt ELSE . noncompleteif_stmt
    (58) other_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE other_stmt
    (59) other_stmt -> . WHILE LPAREN expr RPAREN other_stmt
    (66) other_stmt -> . forbasic other_stmt
    (67) other_stmt -> . RETURN SEMICOLON
    (68) other_stmt -> . RETURN expr SEMICOLON
    (69) other_stmt -> . RETURN error
    (70) other_stmt -> . RETURN expr error
    (71) other_stmt -> . stmt_expr SEMICOLON
    (72) other_stmt -> . stmt_expr error
    (73) other_stmt -> . BREAK SEMICOLON
    (74) other_stmt -> . BREAK error
    (75) other_stmt -> . CONTINUE SEMICOLON
    (76) other_stmt -> . CONTINUE error
    (77) other_stmt -> . block
    (78) other_stmt -> . var_decl
    (79) other_stmt -> . SEMICOLON
    (54) noncompleteif_stmt -> . IF LPAREN expr RPAREN stmt
    (55) noncompleteif_stmt -> . IF LPAREN expr RPAREN other_stmt ELSE noncompleteif_stmt
    (56) noncompleteif_stmt -> . WHILE LPAREN expr RPAREN noncompleteif_stmt
    (57) noncompleteif_stmt -> . forbasic noncompleteif_stmt
    (64) forbasic -> . forbasic2 RPAREN
    (65) forbasic -> . forbasic2 stmt_expr RPAREN
    (134) stmt_expr -> . assign
    (135) stmt_expr -> . method_invocation
    (136) stmt_expr -> . error
    (51) block -> . block1 RBIG
    (26) var_decl -> . type variables SEMICOLON
    (27) var_decl -> . type variables error
    (62) forbasic2 -> . forbasic1 SEMICOLON
    (63) forbasic2 -> . forbasic1 expr SEMICOLON
    (129) assign -> . lhs ASSIGN expr
    (130) assign -> . lhs INCREMENT
    (131) assign -> . INCREMENT lhs
    (132) assign -> . lhs DECREMENT
    (133) assign -> . DECREMENT lhs
    (103) method_invocation -> . field_access LPAREN RPAREN
    (104) method_invocation -> . field_access LPAREN arguments RPAREN
    (49) block1 -> . LBIG
    (50) block1 -> . block1 stmt
    (28) type -> . INT
    (29) type -> . FLOAT
    (30) type -> . BOOLEAN
    (31) type -> . ID
    (32) type -> . error
    (60) forbasic1 -> . FOR LPAREN SEMICOLON
    (61) forbasic1 -> . FOR LPAREN stmt_expr SEMICOLON
    (98) lhs -> . field_access
    (99) lhs -> . array_access
    (100) field_access -> . primary POINT ID
    (101) field_access -> . ID
    (102) array_access -> . primary LSQ expr RSQ
    (86) primary -> . literal
    (87) primary -> . THIS
    (88) primary -> . SUPER
    (89) primary -> . LPAREN expr RPAREN
    (93) primary -> . pnew
    (94) primary -> . lhs
    (95) primary -> . method_invocation
    (80) literal -> . INT_CONST
    (81) literal -> . FLOAT_CONST
    (82) literal -> . STRING_CONST
    (83) literal -> . NULL
    (84) literal -> . TRUE
    (85) literal -> . FALSE
    (91) pnew -> . pnew1 LPAREN RPAREN
    (92) pnew -> . pnew1 LPAREN arguments RPAREN
    (90) pnew1 -> . NEW ID

    IF              shift and go to state 237
    WHILE           shift and go to state 234
    RETURN          shift and go to state 61
    BREAK           shift and go to state 93
    CONTINUE        shift and go to state 95
    SEMICOLON       shift and go to state 70
    error           shift and go to state 97
    INCREMENT       shift and go to state 76
    DECREMENT       shift and go to state 98
    LBIG            shift and go to state 46
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    BOOLEAN         shift and go to state 29
    ID              shift and go to state 88
    FOR             shift and go to state 80
    THIS            shift and go to state 86
    SUPER           shift and go to state 83
    LPAREN          shift and go to state 85
    INT_CONST       shift and go to state 69
    FLOAT_CONST     shift and go to state 64
    STRING_CONST    shift and go to state 68
    NULL            shift and go to state 66
    TRUE            shift and go to state 71
    FALSE           shift and go to state 91
    NEW             shift and go to state 65

    block1                         shift and go to state 45
    primary                        shift and go to state 62
    array_access                   shift and go to state 67
    pnew                           shift and go to state 73
    stmt_expr                      shift and go to state 74
    literal                        shift and go to state 72
    forbasic                       shift and go to state 235
    method_invocation              shift and go to state 77
    type                           shift and go to state 78
    field_access                   shift and go to state 79
    pnew1                          shift and go to state 81
    forbasic2                      shift and go to state 82
    forbasic1                      shift and go to state 87
    noncompleteif_stmt             shift and go to state 245
    var_decl                       shift and go to state 92
    other_stmt                     shift and go to state 246
    lhs                            shift and go to state 96
    assign                         shift and go to state 100
    block                          shift and go to state 101
